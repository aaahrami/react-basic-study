{"ast":null,"code":"/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/* eslint-disable no-use-before-define */\n'use strict';\n\nconst startsWith = (s, c) => s.substr(0, c.length) === c;\n\nconst endsWith = (s, c) => s.substr(s.length - c.length, c.length) === c;\n\nconst unwrap = s => s.slice(1, -1);\n\nconst isObjectString = s => startsWith(s, '{') && endsWith(s, '}');\n\nconst isArrayString = s => startsWith(s, '[') && endsWith(s, ']');\n\nconst isQuotedString = s => startsWith(s, '\\'') && endsWith(s, '\\'') || startsWith(s, '\"') && endsWith(s, '\"');\n\nconst error = (token, string, originalString) => {\n  throw new Error('Unexpected token \\'' + token + '\\' at position ' + (originalString.length - string.length - 1) + ' in string: \\'' + originalString + '\\'');\n};\n\nconst processToken = (token, string, originalString) => {\n  if (token === 'true' || token === 'false') {\n    return token === 'true';\n  } else if (isQuotedString(token)) {\n    return unwrap(token);\n  } else if (!isNaN(token)) {\n    return +token;\n  } else if (isObjectString(token)) {\n    return parseObject(unwrap(token));\n  } else if (isArrayString(token)) {\n    return parseArray(unwrap(token));\n  } else {\n    error(token, string, originalString);\n  }\n};\n\nconst nextToken = string => {\n  string = string.trim();\n  let limit = string.length;\n\n  if (string[0] === ':' || string[0] === ',') {\n    limit = 1;\n  } else if (string[0] === '{' || string[0] === '[') {\n    const c = string.charCodeAt(0);\n    let nestedObject = 1;\n\n    for (let i = 1; i < string.length; i++) {\n      if (string.charCodeAt(i) === c) {\n        nestedObject++;\n      } else if (string.charCodeAt(i) === c + 2) {\n        nestedObject--;\n\n        if (nestedObject === 0) {\n          limit = i + 1;\n          break;\n        }\n      }\n    }\n  } else if (string[0] === '\\'' || string[0] === '\"') {\n    for (let i = 1; i < string.length; i++) {\n      if (string[i] === string[0]) {\n        limit = i + 1;\n        break;\n      }\n    }\n  } else {\n    for (let i = 1; i < string.length; i++) {\n      if ([' ', ',', ':'].indexOf(string[i]) !== -1) {\n        limit = i;\n        break;\n      }\n    }\n  }\n\n  return string.slice(0, limit);\n};\n\nconst parseObject = string => {\n  const isValidKey = key => /^[A-Z_$][A-Z0-9_$]*$/i.test(key);\n\n  string = string.trim();\n  const originalString = string;\n  const object = {};\n  let readingKey = true,\n      key,\n      previousToken,\n      token;\n\n  while (string.length > 0) {\n    previousToken = token;\n    token = nextToken(string);\n    string = string.slice(token.length, string.length).trim();\n\n    if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {\n      error(token, string, originalString);\n    } else if (token === ':' && readingKey && previousToken) {\n      previousToken = isQuotedString(previousToken) ? unwrap(previousToken) : previousToken;\n\n      if (isValidKey(previousToken)) {\n        key = previousToken;\n        readingKey = false;\n      } else {\n        throw new Error('Invalid key token \\'' + previousToken + '\\' at position 0 in string: \\'' + originalString + '\\'');\n      }\n    } else if (token === ',' && !readingKey && previousToken) {\n      object[key] = processToken(previousToken, string, originalString);\n      readingKey = true;\n    }\n  }\n\n  if (token) {\n    object[key] = processToken(token, string, originalString);\n  }\n\n  return object;\n};\n\nconst parseArray = string => {\n  string = string.trim();\n  const originalString = string;\n  const array = [];\n  let previousToken, token;\n\n  while (string.length > 0) {\n    previousToken = token;\n    token = nextToken(string);\n    string = string.slice(token.length, string.length).trim();\n\n    if (token === ',' && (!previousToken || previousToken === ',')) {\n      error(token, string, originalString);\n    } else if (token === ',') {\n      array.push(processToken(previousToken, string, originalString));\n    }\n  }\n\n  if (token) {\n    if (token !== ',') {\n      array.push(processToken(token, string, originalString));\n    } else {\n      error(token, string, originalString);\n    }\n  }\n\n  return array;\n};\n\nconst parse = string => {\n  string = string.trim();\n\n  if (isObjectString(string)) {\n    return parseObject(unwrap(string));\n  } else if (isArrayString(string)) {\n    return parseArray(unwrap(string));\n  } else {\n    throw new Error('Provided string must be object or array like: ' + string);\n  }\n};\n\nexport default parse;","map":{"version":3,"names":["startsWith","s","c","substr","length","endsWith","unwrap","slice","isObjectString","isArrayString","isQuotedString","error","token","string","originalString","Error","processToken","isNaN","parseObject","parseArray","nextToken","trim","limit","charCodeAt","nestedObject","i","indexOf","isValidKey","key","test","object","readingKey","previousToken","array","push","parse"],"sources":["C:/React-app/test/ui/node_modules/onsenui/esm/ons/animation-options-parser.js"],"sourcesContent":["/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/* eslint-disable no-use-before-define */\n\n'use strict';\n\nconst startsWith = (s, c) => s.substr(0, c.length) === c;\nconst endsWith = (s, c) => s.substr(s.length - c.length, c.length) === c;\nconst unwrap = s => s.slice(1, -1);\nconst isObjectString = s => startsWith(s, '{') && endsWith(s, '}');\nconst isArrayString = s => startsWith(s, '[') && endsWith(s, ']');\nconst isQuotedString = s => (startsWith(s, '\\'') && endsWith(s, '\\'')) || (startsWith(s, '\"') && endsWith(s, '\"'));\n\nconst error = (token, string, originalString) => {\n  throw new Error('Unexpected token \\'' + token + '\\' at position ' + (originalString.length - string.length - 1) + ' in string: \\'' + originalString + '\\'');\n};\n\nconst processToken = (token, string, originalString) => {\n  if (token === 'true' || token === 'false') {\n    return token === 'true';\n  } else if (isQuotedString(token)) {\n    return unwrap(token);\n  } else if (!isNaN(token)) {\n    return +(token);\n  } else if (isObjectString(token)) {\n    return parseObject(unwrap(token));\n  } else if (isArrayString(token)) {\n    return parseArray(unwrap(token));\n  } else {\n    error(token, string, originalString);\n  }\n};\n\nconst nextToken = (string) => {\n  string = string.trim();\n  let limit = string.length;\n\n  if (string[0] === ':' || string[0] === ',') {\n\n    limit = 1;\n\n  } else if (string[0] === '{' || string[0] === '[') {\n\n    const c = string.charCodeAt(0);\n    let nestedObject = 1;\n    for (let i = 1; i < string.length; i++) {\n      if (string.charCodeAt(i) === c) {\n        nestedObject++;\n      } else if (string.charCodeAt(i) === c + 2) {\n        nestedObject--;\n        if (nestedObject === 0) {\n          limit = i + 1;\n          break;\n        }\n      }\n    }\n\n  } else if (string[0] === '\\'' || string[0] === '\"') {\n\n    for (let i = 1; i < string.length; i++) {\n      if (string[i] === string[0]) {\n        limit = i + 1;\n        break;\n      }\n    }\n\n  } else {\n\n    for (let i = 1; i < string.length; i++) {\n      if ([' ', ',', ':'].indexOf(string[i]) !== -1) {\n        limit = i;\n        break;\n      }\n    }\n\n  }\n\n  return string.slice(0, limit);\n};\n\nconst parseObject = (string) => {\n  const isValidKey = key => /^[A-Z_$][A-Z0-9_$]*$/i.test(key);\n\n  string = string.trim();\n  const originalString = string;\n  const object = {};\n  let readingKey = true, key, previousToken, token;\n\n  while (string.length > 0) {\n    previousToken = token;\n    token = nextToken(string);\n    string = string.slice(token.length, string.length).trim();\n\n    if ((token === ':' && (!readingKey || !previousToken || previousToken === ','))\n       || (token === ',' && readingKey)\n       || (token !== ':' && token !== ',' && (previousToken && previousToken !== ',' && previousToken !== ':'))) {\n      error(token, string, originalString);\n    } else if (token === ':' && readingKey && previousToken) {\n      previousToken = isQuotedString(previousToken) ? unwrap(previousToken) : previousToken;\n      if (isValidKey(previousToken)) {\n        key = previousToken;\n        readingKey = false;\n      } else {\n        throw new Error('Invalid key token \\'' + previousToken + '\\' at position 0 in string: \\'' + originalString + '\\'');\n      }\n    } else if (token === ',' && !readingKey && previousToken) {\n      object[key] = processToken(previousToken, string, originalString);\n      readingKey = true;\n    }\n  }\n\n  if (token) {\n    object[key] = processToken(token, string, originalString);\n  }\n\n  return object;\n};\n\nconst parseArray = (string) => {\n  string = string.trim();\n  const originalString = string;\n  const array = [];\n  let previousToken, token;\n\n  while (string.length > 0) {\n    previousToken = token;\n    token = nextToken(string);\n    string = string.slice(token.length, string.length).trim();\n\n    if (token === ',' && (!previousToken || previousToken === ',')) {\n      error(token, string, originalString);\n    } else if (token === ',') {\n      array.push(processToken(previousToken, string, originalString));\n    }\n  }\n\n  if (token) {\n    if (token !== ',') {\n      array.push(processToken(token, string, originalString));\n    } else {\n      error(token, string, originalString);\n    }\n  }\n\n  return array;\n};\n\nconst parse = (string) => {\n  string = string.trim();\n\n  if (isObjectString(string)) {\n    return parseObject(unwrap(string));\n  } else if (isArrayString(string)) {\n    return parseArray(unwrap(string));\n  } else {\n    throw new Error('Provided string must be object or array like: ' + string);\n  }\n};\n\nexport default parse;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;AAEA,MAAMA,UAAU,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,MAAF,CAAS,CAAT,EAAYD,CAAC,CAACE,MAAd,MAA0BF,CAAvD;;AACA,MAAMG,QAAQ,GAAG,CAACJ,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,MAAF,CAASF,CAAC,CAACG,MAAF,GAAWF,CAAC,CAACE,MAAtB,EAA8BF,CAAC,CAACE,MAAhC,MAA4CF,CAAvE;;AACA,MAAMI,MAAM,GAAGL,CAAC,IAAIA,CAAC,CAACM,KAAF,CAAQ,CAAR,EAAW,CAAC,CAAZ,CAApB;;AACA,MAAMC,cAAc,GAAGP,CAAC,IAAID,UAAU,CAACC,CAAD,EAAI,GAAJ,CAAV,IAAsBI,QAAQ,CAACJ,CAAD,EAAI,GAAJ,CAA1D;;AACA,MAAMQ,aAAa,GAAGR,CAAC,IAAID,UAAU,CAACC,CAAD,EAAI,GAAJ,CAAV,IAAsBI,QAAQ,CAACJ,CAAD,EAAI,GAAJ,CAAzD;;AACA,MAAMS,cAAc,GAAGT,CAAC,IAAKD,UAAU,CAACC,CAAD,EAAI,IAAJ,CAAV,IAAuBI,QAAQ,CAACJ,CAAD,EAAI,IAAJ,CAAhC,IAA+CD,UAAU,CAACC,CAAD,EAAI,GAAJ,CAAV,IAAsBI,QAAQ,CAACJ,CAAD,EAAI,GAAJ,CAAzG;;AAEA,MAAMU,KAAK,GAAG,CAACC,KAAD,EAAQC,MAAR,EAAgBC,cAAhB,KAAmC;EAC/C,MAAM,IAAIC,KAAJ,CAAU,wBAAwBH,KAAxB,GAAgC,iBAAhC,IAAqDE,cAAc,CAACV,MAAf,GAAwBS,MAAM,CAACT,MAA/B,GAAwC,CAA7F,IAAkG,gBAAlG,GAAqHU,cAArH,GAAsI,IAAhJ,CAAN;AACD,CAFD;;AAIA,MAAME,YAAY,GAAG,CAACJ,KAAD,EAAQC,MAAR,EAAgBC,cAAhB,KAAmC;EACtD,IAAIF,KAAK,KAAK,MAAV,IAAoBA,KAAK,KAAK,OAAlC,EAA2C;IACzC,OAAOA,KAAK,KAAK,MAAjB;EACD,CAFD,MAEO,IAAIF,cAAc,CAACE,KAAD,CAAlB,EAA2B;IAChC,OAAON,MAAM,CAACM,KAAD,CAAb;EACD,CAFM,MAEA,IAAI,CAACK,KAAK,CAACL,KAAD,CAAV,EAAmB;IACxB,OAAO,CAAEA,KAAT;EACD,CAFM,MAEA,IAAIJ,cAAc,CAACI,KAAD,CAAlB,EAA2B;IAChC,OAAOM,WAAW,CAACZ,MAAM,CAACM,KAAD,CAAP,CAAlB;EACD,CAFM,MAEA,IAAIH,aAAa,CAACG,KAAD,CAAjB,EAA0B;IAC/B,OAAOO,UAAU,CAACb,MAAM,CAACM,KAAD,CAAP,CAAjB;EACD,CAFM,MAEA;IACLD,KAAK,CAACC,KAAD,EAAQC,MAAR,EAAgBC,cAAhB,CAAL;EACD;AACF,CAdD;;AAgBA,MAAMM,SAAS,GAAIP,MAAD,IAAY;EAC5BA,MAAM,GAAGA,MAAM,CAACQ,IAAP,EAAT;EACA,IAAIC,KAAK,GAAGT,MAAM,CAACT,MAAnB;;EAEA,IAAIS,MAAM,CAAC,CAAD,CAAN,KAAc,GAAd,IAAqBA,MAAM,CAAC,CAAD,CAAN,KAAc,GAAvC,EAA4C;IAE1CS,KAAK,GAAG,CAAR;EAED,CAJD,MAIO,IAAIT,MAAM,CAAC,CAAD,CAAN,KAAc,GAAd,IAAqBA,MAAM,CAAC,CAAD,CAAN,KAAc,GAAvC,EAA4C;IAEjD,MAAMX,CAAC,GAAGW,MAAM,CAACU,UAAP,CAAkB,CAAlB,CAAV;IACA,IAAIC,YAAY,GAAG,CAAnB;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,MAAM,CAACT,MAA3B,EAAmCqB,CAAC,EAApC,EAAwC;MACtC,IAAIZ,MAAM,CAACU,UAAP,CAAkBE,CAAlB,MAAyBvB,CAA7B,EAAgC;QAC9BsB,YAAY;MACb,CAFD,MAEO,IAAIX,MAAM,CAACU,UAAP,CAAkBE,CAAlB,MAAyBvB,CAAC,GAAG,CAAjC,EAAoC;QACzCsB,YAAY;;QACZ,IAAIA,YAAY,KAAK,CAArB,EAAwB;UACtBF,KAAK,GAAGG,CAAC,GAAG,CAAZ;UACA;QACD;MACF;IACF;EAEF,CAhBM,MAgBA,IAAIZ,MAAM,CAAC,CAAD,CAAN,KAAc,IAAd,IAAsBA,MAAM,CAAC,CAAD,CAAN,KAAc,GAAxC,EAA6C;IAElD,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,MAAM,CAACT,MAA3B,EAAmCqB,CAAC,EAApC,EAAwC;MACtC,IAAIZ,MAAM,CAACY,CAAD,CAAN,KAAcZ,MAAM,CAAC,CAAD,CAAxB,EAA6B;QAC3BS,KAAK,GAAGG,CAAC,GAAG,CAAZ;QACA;MACD;IACF;EAEF,CATM,MASA;IAEL,KAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,MAAM,CAACT,MAA3B,EAAmCqB,CAAC,EAApC,EAAwC;MACtC,IAAI,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgBC,OAAhB,CAAwBb,MAAM,CAACY,CAAD,CAA9B,MAAuC,CAAC,CAA5C,EAA+C;QAC7CH,KAAK,GAAGG,CAAR;QACA;MACD;IACF;EAEF;;EAED,OAAOZ,MAAM,CAACN,KAAP,CAAa,CAAb,EAAgBe,KAAhB,CAAP;AACD,CA7CD;;AA+CA,MAAMJ,WAAW,GAAIL,MAAD,IAAY;EAC9B,MAAMc,UAAU,GAAGC,GAAG,IAAI,wBAAwBC,IAAxB,CAA6BD,GAA7B,CAA1B;;EAEAf,MAAM,GAAGA,MAAM,CAACQ,IAAP,EAAT;EACA,MAAMP,cAAc,GAAGD,MAAvB;EACA,MAAMiB,MAAM,GAAG,EAAf;EACA,IAAIC,UAAU,GAAG,IAAjB;EAAA,IAAuBH,GAAvB;EAAA,IAA4BI,aAA5B;EAAA,IAA2CpB,KAA3C;;EAEA,OAAOC,MAAM,CAACT,MAAP,GAAgB,CAAvB,EAA0B;IACxB4B,aAAa,GAAGpB,KAAhB;IACAA,KAAK,GAAGQ,SAAS,CAACP,MAAD,CAAjB;IACAA,MAAM,GAAGA,MAAM,CAACN,KAAP,CAAaK,KAAK,CAACR,MAAnB,EAA2BS,MAAM,CAACT,MAAlC,EAA0CiB,IAA1C,EAAT;;IAEA,IAAKT,KAAK,KAAK,GAAV,KAAkB,CAACmB,UAAD,IAAe,CAACC,aAAhB,IAAiCA,aAAa,KAAK,GAArE,CAAD,IACGpB,KAAK,KAAK,GAAV,IAAiBmB,UADpB,IAEGnB,KAAK,KAAK,GAAV,IAAiBA,KAAK,KAAK,GAA3B,IAAmCoB,aAAa,IAAIA,aAAa,KAAK,GAAnC,IAA0CA,aAAa,KAAK,GAFtG,EAE6G;MAC3GrB,KAAK,CAACC,KAAD,EAAQC,MAAR,EAAgBC,cAAhB,CAAL;IACD,CAJD,MAIO,IAAIF,KAAK,KAAK,GAAV,IAAiBmB,UAAjB,IAA+BC,aAAnC,EAAkD;MACvDA,aAAa,GAAGtB,cAAc,CAACsB,aAAD,CAAd,GAAgC1B,MAAM,CAAC0B,aAAD,CAAtC,GAAwDA,aAAxE;;MACA,IAAIL,UAAU,CAACK,aAAD,CAAd,EAA+B;QAC7BJ,GAAG,GAAGI,aAAN;QACAD,UAAU,GAAG,KAAb;MACD,CAHD,MAGO;QACL,MAAM,IAAIhB,KAAJ,CAAU,yBAAyBiB,aAAzB,GAAyC,gCAAzC,GAA4ElB,cAA5E,GAA6F,IAAvG,CAAN;MACD;IACF,CARM,MAQA,IAAIF,KAAK,KAAK,GAAV,IAAiB,CAACmB,UAAlB,IAAgCC,aAApC,EAAmD;MACxDF,MAAM,CAACF,GAAD,CAAN,GAAcZ,YAAY,CAACgB,aAAD,EAAgBnB,MAAhB,EAAwBC,cAAxB,CAA1B;MACAiB,UAAU,GAAG,IAAb;IACD;EACF;;EAED,IAAInB,KAAJ,EAAW;IACTkB,MAAM,CAACF,GAAD,CAAN,GAAcZ,YAAY,CAACJ,KAAD,EAAQC,MAAR,EAAgBC,cAAhB,CAA1B;EACD;;EAED,OAAOgB,MAAP;AACD,CApCD;;AAsCA,MAAMX,UAAU,GAAIN,MAAD,IAAY;EAC7BA,MAAM,GAAGA,MAAM,CAACQ,IAAP,EAAT;EACA,MAAMP,cAAc,GAAGD,MAAvB;EACA,MAAMoB,KAAK,GAAG,EAAd;EACA,IAAID,aAAJ,EAAmBpB,KAAnB;;EAEA,OAAOC,MAAM,CAACT,MAAP,GAAgB,CAAvB,EAA0B;IACxB4B,aAAa,GAAGpB,KAAhB;IACAA,KAAK,GAAGQ,SAAS,CAACP,MAAD,CAAjB;IACAA,MAAM,GAAGA,MAAM,CAACN,KAAP,CAAaK,KAAK,CAACR,MAAnB,EAA2BS,MAAM,CAACT,MAAlC,EAA0CiB,IAA1C,EAAT;;IAEA,IAAIT,KAAK,KAAK,GAAV,KAAkB,CAACoB,aAAD,IAAkBA,aAAa,KAAK,GAAtD,CAAJ,EAAgE;MAC9DrB,KAAK,CAACC,KAAD,EAAQC,MAAR,EAAgBC,cAAhB,CAAL;IACD,CAFD,MAEO,IAAIF,KAAK,KAAK,GAAd,EAAmB;MACxBqB,KAAK,CAACC,IAAN,CAAWlB,YAAY,CAACgB,aAAD,EAAgBnB,MAAhB,EAAwBC,cAAxB,CAAvB;IACD;EACF;;EAED,IAAIF,KAAJ,EAAW;IACT,IAAIA,KAAK,KAAK,GAAd,EAAmB;MACjBqB,KAAK,CAACC,IAAN,CAAWlB,YAAY,CAACJ,KAAD,EAAQC,MAAR,EAAgBC,cAAhB,CAAvB;IACD,CAFD,MAEO;MACLH,KAAK,CAACC,KAAD,EAAQC,MAAR,EAAgBC,cAAhB,CAAL;IACD;EACF;;EAED,OAAOmB,KAAP;AACD,CA3BD;;AA6BA,MAAME,KAAK,GAAItB,MAAD,IAAY;EACxBA,MAAM,GAAGA,MAAM,CAACQ,IAAP,EAAT;;EAEA,IAAIb,cAAc,CAACK,MAAD,CAAlB,EAA4B;IAC1B,OAAOK,WAAW,CAACZ,MAAM,CAACO,MAAD,CAAP,CAAlB;EACD,CAFD,MAEO,IAAIJ,aAAa,CAACI,MAAD,CAAjB,EAA2B;IAChC,OAAOM,UAAU,CAACb,MAAM,CAACO,MAAD,CAAP,CAAjB;EACD,CAFM,MAEA;IACL,MAAM,IAAIE,KAAJ,CAAU,mDAAmDF,MAA7D,CAAN;EACD;AACF,CAVD;;AAYA,eAAesB,KAAf"},"metadata":{},"sourceType":"module"}