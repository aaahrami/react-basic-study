{"ast":null,"code":"/*\n * Gesture detector library that forked from github.com/EightMedia/hammer.js.\n */\n'use strict';\n\nimport util from './util.js';\nvar Event, Utils, Detection, PointerEvent;\n/**\n * @object ons.GestureDetector\n * @category gesture\n * @description\n *   [en]Utility class for gesture detection.[/en]\n *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]\n */\n\n/**\n * @method constructor\n * @signature constructor(element[, options])\n * @description\n *  [en]Create a new GestureDetector instance.[/en]\n *  [ja]GestureDetectorのインスタンスを生成します。[/ja]\n * @param {Element} element\n *   [en]Name of the event.[/en]\n *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]\n * @param {Object} [options]\n *   [en]Options object.[/en]\n *   [ja]オプションを指定します。[/ja]\n * @return {ons.GestureDetector.Instance}\n */\n\nvar GestureDetector = function GestureDetector(element, options) {\n  return new GestureDetector.Instance(element, options || {});\n};\n/**\n * default settings.\n * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled\n * by setting it's name (like `swipe`) to false.\n * You can set the defaults for all instances by changing this object before creating an instance.\n * @example\n * ````\n *  GestureDetector.defaults.drag = false;\n *  GestureDetector.defaults.behavior.touchAction = 'pan-y';\n *  delete GestureDetector.defaults.behavior.userSelect;\n * ````\n * @property defaults\n * @type {Object}\n */\n\n\nGestureDetector.defaults = {\n  behavior: {\n    // userSelect: 'none', // Also disables selection in `input` children\n    touchAction: 'pan-y',\n    touchCallout: 'none',\n    contentZooming: 'none',\n    userDrag: 'none',\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n};\n/**\n * GestureDetector document where the base events are added at\n * @property DOCUMENT\n * @type {HTMLElement}\n * @default window.document\n */\n\nGestureDetector.DOCUMENT = document;\n/**\n * detect support for pointer events\n * @property HAS_POINTEREVENTS\n * @type {Boolean}\n */\n\nGestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;\n/**\n * detect support for touch events\n * @property HAS_TOUCHEVENTS\n * @type {Boolean}\n */\n\nGestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;\n/**\n * detect mobile browsers\n * @property IS_MOBILE\n * @type {Boolean}\n */\n\nGestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);\n/**\n * detect if we want to support mouseevents at all\n * @property NO_MOUSEEVENTS\n * @type {Boolean}\n */\n\nGestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;\n/**\n * interval in which GestureDetector recalculates current velocity/direction/angle in ms\n * @property CALCULATE_INTERVAL\n * @type {Number}\n * @default 25\n */\n\nGestureDetector.CALCULATE_INTERVAL = 25;\n/**\n * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`\n * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)\n * @property EVENT_TYPES\n * @private\n * @writeOnce\n * @type {Object}\n */\n\nvar EVENT_TYPES = {};\n/**\n * direction strings, for safe comparisons\n * @property DIRECTION_DOWN|LEFT|UP|RIGHT\n * @final\n * @type {String}\n * @default 'down' 'left' 'up' 'right'\n */\n\nvar DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';\nvar DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';\nvar DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';\nvar DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';\n/**\n * pointertype strings, for safe comparisons\n * @property POINTER_MOUSE|TOUCH|PEN\n * @final\n * @type {String}\n * @default 'mouse' 'touch' 'pen'\n */\n\nvar POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';\nvar POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';\nvar POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';\n/**\n * eventtypes\n * @property EVENT_START|MOVE|END|RELEASE|TOUCH\n * @final\n * @type {String}\n * @default 'start' 'change' 'move' 'end' 'release' 'touch'\n */\n\nvar EVENT_START = GestureDetector.EVENT_START = 'start';\nvar EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';\nvar EVENT_END = GestureDetector.EVENT_END = 'end';\nvar EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';\nvar EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';\n/**\n * if the window events are set...\n * @property READY\n * @writeOnce\n * @type {Boolean}\n * @default false\n */\n\nGestureDetector.READY = false;\n/**\n * plugins namespace\n * @property plugins\n * @type {Object}\n */\n\nGestureDetector.plugins = GestureDetector.plugins || {};\n/**\n * gestures namespace\n * see `/gestures` for the definitions\n * @property gestures\n * @type {Object}\n */\n\nGestureDetector.gestures = GestureDetector.gestures || {};\n/**\n * setup events to detect gestures on the document\n * this function is called when creating an new instance\n * @private\n */\n\nfunction setup(opts) {\n  if (GestureDetector.READY) {\n    return;\n  } // find what eventtypes we add listeners to\n\n\n  Event.determineEventTypes(); // Register all gestures inside GestureDetector.gestures\n\n  Utils.each(GestureDetector.gestures, function (gesture) {\n    Detection.register(gesture);\n  }); // Add touch events on the document\n\n  Event.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect, opts);\n  Event.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect, opts); // GestureDetector is ready...!\n\n  GestureDetector.READY = true;\n}\n/**\n * @module GestureDetector\n *\n * @class Utils\n * @static\n */\n\n\nUtils = GestureDetector.utils = {\n  /**\n   * extend method, could also be used for cloning when `dest` is an empty object.\n   * changes the dest object\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]  do a merge\n   * @return {Object} dest\n   */\n  extend: function extend(dest, src, merge) {\n    for (var key in src) {\n      if (Object.prototype.hasOwnProperty.call(src, key) && (dest[key] === undefined || !merge)) {\n        dest[key] = src[key];\n      }\n    }\n\n    return dest;\n  },\n\n  /**\n   * simple addEventListener wrapper\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   */\n  on: function on(element, type, handler, opt) {\n    util.addEventListener(element, type, handler, opt, true);\n  },\n\n  /**\n   * simple removeEventListener wrapper\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   */\n  off: function off(element, type, handler, opt) {\n    util.removeEventListener(element, type, handler, opt, true);\n  },\n\n  /**\n   * forEach over arrays and objects\n   * @param {Object|Array} obj\n   * @param {Function} iterator\n   * @param {any} iterator.item\n   * @param {Number} iterator.index\n   * @param {Object|Array} iterator.obj the source object\n   * @param {Object} context value to use as `this` in the iterator\n   */\n  each: function each(obj, iterator, context) {\n    var i, len; // native forEach on arrays\n\n    if ('forEach' in obj) {\n      obj.forEach(iterator, context); // arrays\n    } else if (obj.length !== undefined) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        if (iterator.call(context, obj[i], i, obj) === false) {\n          return;\n        }\n      } // objects\n\n    } else {\n      for (i in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, i) && iterator.call(context, obj[i], i, obj) === false) {\n          return;\n        }\n      }\n    }\n  },\n\n  /**\n   * find if a string contains the string using indexOf\n   * @param {String} src\n   * @param {String} find\n   * @return {Boolean} found\n   */\n  inStr: function inStr(src, find) {\n    return src.indexOf(find) > -1;\n  },\n\n  /**\n   * find if a array contains the object using indexOf or a simple polyfill\n   * @param {String} src\n   * @param {String} find\n   * @return {Boolean|Number} false when not found, or the index\n   */\n  inArray: function inArray(src, find, deep) {\n    if (deep) {\n      for (var i = 0, len = src.length; i < len; i++) {\n        // Array.findIndex\n        if (Object.keys(find).every(function (key) {\n          return src[i][key] === find[key];\n        })) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n\n    if (src.indexOf) {\n      return src.indexOf(find);\n    } else {\n      for (var i = 0, len = src.length; i < len; i++) {\n        if (src[i] === find) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  },\n\n  /**\n   * convert an array-like object (`arguments`, `touchlist`) to an array\n   * @param {Object} obj\n   * @return {Array}\n   */\n  toArray: function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  },\n\n  /**\n   * find if a node is in the given parent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n  hasParent: function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n\n      node = node.parentNode;\n    }\n\n    return false;\n  },\n\n  /**\n   * get the center of all the touches\n   * @param {Array} touches\n   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties\n   */\n  getCenter: function getCenter(touches) {\n    var pageX = [],\n        pageY = [],\n        clientX = [],\n        clientY = [],\n        min = Math.min,\n        max = Math.max; // no need to loop when only one touch\n\n    if (touches.length === 1) {\n      return {\n        pageX: touches[0].pageX,\n        pageY: touches[0].pageY,\n        clientX: touches[0].clientX,\n        clientY: touches[0].clientY\n      };\n    }\n\n    Utils.each(touches, function (touch) {\n      pageX.push(touch.pageX);\n      pageY.push(touch.pageY);\n      clientX.push(touch.clientX);\n      clientY.push(touch.clientY);\n    });\n    return {\n      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,\n      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,\n      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,\n      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2\n    };\n  },\n\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} deltaX\n   * @param {Number} deltaY\n   * @return {Object} velocity `x` and `y`\n   */\n  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {\n    return {\n      x: Math.abs(deltaX / deltaTime) || 0,\n      y: Math.abs(deltaY / deltaTime) || 0\n    };\n  },\n\n  /**\n   * calculate the angle between two coordinates\n   * @param {Touch} touch1\n   * @param {Touch} touch2\n   * @return {Number} angle\n   */\n  getAngle: function getAngle(touch1, touch2) {\n    var x = touch2.clientX - touch1.clientX,\n        y = touch2.clientY - touch1.clientY;\n    return Math.atan2(y, x) * 180 / Math.PI;\n  },\n\n  /**\n   * do a small comparison to get the direction between two touches.\n   * @param {Touch} touch1\n   * @param {Touch} touch2\n   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`\n   */\n  getDirection: function getDirection(touch1, touch2) {\n    var x = Math.abs(touch1.clientX - touch2.clientX),\n        y = Math.abs(touch1.clientY - touch2.clientY);\n\n    if (x >= y) {\n      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n\n    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  },\n\n  /**\n   * calculate the distance between two touches\n   * @param {Touch}touch1\n   * @param {Touch} touch2\n   * @return {Number} distance\n   */\n  getDistance: function getDistance(touch1, touch2) {\n    var x = touch2.clientX - touch1.clientX,\n        y = touch2.clientY - touch1.clientY;\n    return Math.sqrt(x * x + y * y);\n  },\n\n  /**\n   * calculate the scale factor between two touchLists\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of touches\n   * @param {Array} end array of touches\n   * @return {Number} scale\n   */\n  getScale: function getScale(start, end) {\n    // need two fingers...\n    if (start.length >= 2 && end.length >= 2) {\n      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);\n    }\n\n    return 1;\n  },\n\n  /**\n   * calculate the rotation degrees between two touchLists\n   * @param {Array} start array of touches\n   * @param {Array} end array of touches\n   * @return {Number} rotation\n   */\n  getRotation: function getRotation(start, end) {\n    // need two fingers\n    if (start.length >= 2 && end.length >= 2) {\n      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);\n    }\n\n    return 0;\n  },\n\n  /**\n   * find out if the direction is vertical   *\n   * @param {String} direction matches `DIRECTION_UP|DOWN`\n   * @return {Boolean} is_vertical\n   */\n  isVertical: function isVertical(direction) {\n    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;\n  },\n\n  /**\n   * set css properties with their prefixes\n   * @param {HTMLElement} element\n   * @param {String} prop\n   * @param {String} value\n   * @param {Boolean} [toggle=true]\n   * @return {Boolean}\n   */\n  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {\n    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];\n    prop = Utils.toCamelCase(prop);\n\n    for (var i = 0; i < prefixes.length; i++) {\n      var p = prop; // prefixes\n\n      if (prefixes[i]) {\n        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);\n      } // test the style\n\n\n      if (p in element.style) {\n        element.style[p] = (toggle === null || toggle) && value || '';\n        break;\n      }\n    }\n  },\n\n  /**\n   * toggle browser default behavior by setting css properties.\n   * `userSelect='none'` also sets `element.onselectstart` to false\n   * `userDrag='none'` also sets `element.ondragstart` to false\n   *\n   * @param {HtmlElement} element\n   * @param {Object} props\n   * @param {Boolean} [toggle=true]\n   */\n  toggleBehavior: function toggleBehavior(element, props, toggle) {\n    if (!props || !element || !element.style) {\n      return;\n    } // set the css properties\n\n\n    Utils.each(props, function (value, prop) {\n      Utils.setPrefixedCss(element, prop, value, toggle);\n    });\n\n    var falseFn = toggle && function () {\n      return false;\n    }; // also the disable onselectstart\n\n\n    if (props.userSelect == 'none') {\n      element.onselectstart = falseFn;\n    } // and disable ondragstart\n\n\n    if (props.userDrag == 'none') {\n      element.ondragstart = falseFn;\n    }\n  },\n\n  /**\n   * convert a string with underscores to camelCase\n   * so prevent_default becomes preventDefault\n   * @param {String} str\n   * @return {String} camelCaseStr\n   */\n  toCamelCase: function toCamelCase(str) {\n    return str.replace(/[_-]([a-z])/g, function (s) {\n      return s[1].toUpperCase();\n    });\n  }\n};\n/**\n * @module GestureDetector\n */\n\n/**\n * @class Event\n * @static\n */\n\nEvent = GestureDetector.event = {\n  /**\n   * when touch events have been fired, this is true\n   * this is used to stop mouse events\n   * @property prevent_mouseevents\n   * @private\n   * @type {Boolean}\n   */\n  preventMouseEvents: false,\n\n  /**\n   * if EVENT_START has been fired\n   * @property started\n   * @private\n   * @type {Boolean}\n   */\n  started: false,\n\n  /**\n   * when the mouse is hold down, this is true\n   * @property should_detect\n   * @private\n   * @type {Boolean}\n   */\n  shouldDetect: false,\n\n  /**\n   * simple event binder with a hook and support for multiple types\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   * @param {Object} [opt]\n   * @param {Function} [hook]\n   * @param {Object} hook.type\n   */\n  on: function on(element, type, handler, opt, hook) {\n    var types = type.split(' ');\n    Utils.each(types, function (type) {\n      Utils.on(element, type, handler, opt);\n      hook && hook(type);\n    });\n  },\n\n  /**\n   * simple event unbinder with a hook and support for multiple types\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   * @param {Object} [opt]\n   * @param {Function} [hook]\n   * @param {Object} hook.type\n   */\n  off: function off(element, type, handler, opt, hook) {\n    var types = type.split(' ');\n    Utils.each(types, function (type) {\n      Utils.off(element, type, handler, opt);\n      hook && hook(type);\n    });\n  },\n\n  /**\n   * the core touch event handler.\n   * this finds out if we should to detect gestures\n   * @param {HTMLElement} element\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Function} handler\n   * @return onTouchHandler {Function} the core event handler\n   */\n  onTouch: function onTouch(element, eventType, handler, opt) {\n    var self = this;\n\n    var onTouchHandler = function onTouchHandler(ev) {\n      var srcType = ev.type.toLowerCase(),\n          isPointer = GestureDetector.HAS_POINTEREVENTS,\n          isMouse = Utils.inStr(srcType, 'mouse'),\n          triggerType; // if we are in a mouseevent, but there has been a touchevent triggered in this session\n      // we want to do nothing. simply break out of the event.\n\n      if (isMouse && self.preventMouseEvents) {\n        return; // mousebutton must be down\n      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {\n        self.preventMouseEvents = false;\n        self.shouldDetect = true;\n      } else if (isPointer && eventType == EVENT_START) {\n        self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev); // just a valid start event, but no mouse\n      } else if (!isMouse && eventType == EVENT_START) {\n        self.preventMouseEvents = true;\n        self.shouldDetect = true;\n      } // update the pointer event before entering the detection\n\n\n      if (isPointer && eventType != EVENT_END) {\n        PointerEvent.updatePointer(eventType, ev);\n      } // we are in a touch/down state, so allowed detection of gestures\n\n\n      if (self.shouldDetect) {\n        triggerType = self.doDetect.call(self, ev, eventType, element, handler);\n      } // ...and we are done with the detection\n      // so reset everything to start each detection totally fresh\n\n\n      if (triggerType == EVENT_END) {\n        self.preventMouseEvents = false;\n        self.shouldDetect = false;\n        PointerEvent.reset(); // update the pointerevent object after the detection\n      }\n\n      if (isPointer && eventType == EVENT_END) {\n        PointerEvent.updatePointer(eventType, ev);\n      }\n    };\n\n    this.on(element, EVENT_TYPES[eventType], onTouchHandler, opt);\n    return onTouchHandler;\n  },\n\n  /**\n   * the core detection method\n   * this finds out what GestureDetector-touch-events to trigger\n   * @param {Object} ev\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {HTMLElement} element\n   * @param {Function} handler\n   * @return {String} triggerType matches `EVENT_START|MOVE|END`\n   */\n  doDetect: function doDetect(ev, eventType, element, handler) {\n    var touchList = this.getTouchList(ev, eventType);\n    var touchListLength = touchList.length;\n    var triggerType = eventType;\n    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin\n\n    var changedLength = touchListLength; // at each touchstart-like event we want also want to trigger a TOUCH event...\n\n    if (eventType == EVENT_START) {\n      triggerChange = EVENT_TOUCH; // ...the same for a touchend-like event\n    } else if (eventType == EVENT_END) {\n      triggerChange = EVENT_RELEASE; // keep track of how many touches have been removed\n\n      changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);\n    } // after there are still touches on the screen,\n    // we just want to trigger a MOVE event. so change the START or END to a MOVE\n    // but only after detection has been started, the first time we actually want a START\n\n\n    if (changedLength > 0 && this.started) {\n      triggerType = EVENT_MOVE;\n    } // detection has been started, we keep track of this, see above\n\n\n    this.started = true; // generate some event data, some basic information\n\n    var evData = this.collectEventData(element, triggerType, touchList, ev); // trigger the triggerType event before the change (TOUCH, RELEASE) events\n    // but the END event should be at last\n\n    if (eventType != EVENT_END) {\n      handler.call(Detection, evData);\n    } // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed\n\n\n    if (triggerChange) {\n      evData.changedLength = changedLength;\n      evData.eventType = triggerChange;\n      handler.call(Detection, evData);\n      evData.eventType = triggerType;\n      delete evData.changedLength;\n    } // trigger the END event\n\n\n    if (triggerType == EVENT_END) {\n      handler.call(Detection, evData); // ...and we are done with the detection\n      // so reset everything to start each detection totally fresh\n\n      this.started = false;\n    }\n\n    return triggerType;\n  },\n\n  /**\n   * we have different events for each device/browser\n   * determine what we need and set them in the EVENT_TYPES constant\n   * the `onTouch` method is bind to these properties.\n   * @return {Object} events\n   */\n  determineEventTypes: function determineEventTypes() {\n    var types;\n\n    if (GestureDetector.HAS_POINTEREVENTS) {\n      if (window.PointerEvent) {\n        types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];\n      } else {\n        types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];\n      }\n    } else if (GestureDetector.NO_MOUSEEVENTS) {\n      types = ['touchstart', 'touchmove', 'touchend touchcancel'];\n    } else {\n      types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];\n    }\n\n    EVENT_TYPES[EVENT_START] = types[0];\n    EVENT_TYPES[EVENT_MOVE] = types[1];\n    EVENT_TYPES[EVENT_END] = types[2];\n    return EVENT_TYPES;\n  },\n\n  /**\n   * create touchList depending on the event\n   * @param {Object} ev\n   * @param {String} eventType\n   * @return {Array} touches\n   */\n  getTouchList: function getTouchList(ev, eventType) {\n    // get the fake pointerEvent touchlist\n    if (GestureDetector.HAS_POINTEREVENTS) {\n      return PointerEvent.getTouchList();\n    } // get the touchlist\n\n\n    if (ev.touches) {\n      if (eventType == EVENT_MOVE) {\n        return ev.touches;\n      }\n\n      var identifiers = [];\n      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));\n      var touchList = [];\n      Utils.each(concat, function (touch) {\n        if (Utils.inArray(identifiers, touch.identifier) === -1) {\n          touchList.push(touch);\n        }\n\n        identifiers.push(touch.identifier);\n      });\n      return touchList;\n    } // make fake touchList from mouse position\n\n\n    ev.identifier = 1;\n    return [ev];\n  },\n\n  /**\n   * collect basic event data\n   * @param {HTMLElement} element\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Array} touches\n   * @param {Object} ev\n   * @return {Object} ev\n   */\n  collectEventData: function collectEventData(element, eventType, touches, ev) {\n    // find out pointerType\n    var pointerType = POINTER_TOUCH;\n\n    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {\n      pointerType = POINTER_MOUSE;\n    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {\n      pointerType = POINTER_PEN;\n    }\n\n    return {\n      center: Utils.getCenter(touches),\n      timeStamp: Date.now(),\n      target: ev.target,\n      touches: touches,\n      eventType: eventType,\n      pointerType: pointerType,\n      srcEvent: ev,\n\n      /**\n       * prevent the browser default actions\n       * mostly used to disable scrolling of the browser\n       */\n      preventDefault: function () {\n        var srcEvent = this.srcEvent;\n        srcEvent.preventManipulation && srcEvent.preventManipulation();\n        srcEvent.preventDefault && srcEvent.preventDefault();\n      },\n\n      /**\n       * stop bubbling the event up to its parents\n       */\n      stopPropagation: function () {\n        this.srcEvent.stopPropagation();\n      },\n\n      /**\n       * immediately stop gesture detection\n       * might be useful after a swipe was detected\n       * @return {*}\n       */\n      stopDetect: function () {\n        return Detection.stopDetect();\n      }\n    };\n  }\n};\n/**\n * @module GestureDetector\n *\n * @class PointerEvent\n * @static\n */\n\nPointerEvent = GestureDetector.PointerEvent = {\n  /**\n   * holds all pointers, by `identifier`\n   * @property pointers\n   * @type {Object}\n   */\n  pointers: {},\n\n  /**\n   * get the pointers as an array\n   * @return {Array} touchlist\n   */\n  getTouchList: function getTouchList() {\n    var touchlist = []; // we can use forEach since pointerEvents only is in IE10\n\n    Utils.each(this.pointers, function (pointer) {\n      touchlist.push(pointer);\n    });\n    return touchlist;\n  },\n\n  /**\n   * update the position of a pointer\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Object} pointerEvent\n   */\n  updatePointer: function updatePointer(eventType, pointerEvent) {\n    if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {\n      delete this.pointers[pointerEvent.pointerId];\n    } else {\n      pointerEvent.identifier = pointerEvent.pointerId;\n      this.pointers[pointerEvent.pointerId] = pointerEvent;\n    }\n  },\n\n  /**\n   * check if ev matches pointertype\n   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`\n   * @param {PointerEvent} ev\n   */\n  matchType: function matchType(pointerType, ev) {\n    if (!ev.pointerType) {\n      return false;\n    }\n\n    var pt = ev.pointerType,\n        types = {};\n    types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);\n    types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);\n    types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);\n    return types[pointerType];\n  },\n\n  /**\n   * reset the stored pointers\n   */\n  reset: function resetList() {\n    this.pointers = {};\n  }\n};\n/**\n * @module GestureDetector\n *\n * @class Detection\n * @static\n */\n\nDetection = GestureDetector.detection = {\n  // contains all registered GestureDetector.gestures in the correct order\n  gestures: [],\n  // data of the current GestureDetector.gesture detection session\n  current: null,\n  // the previous GestureDetector.gesture session data\n  // is a full clone of the previous gesture.current object\n  previous: null,\n  // when this becomes true, no gestures are fired\n  stopped: false,\n\n  /**\n   * start GestureDetector.gesture detection\n   * @param {GestureDetector.Instance} inst\n   * @param {Object} eventData\n   */\n  startDetect: function startDetect(inst, eventData) {\n    // already busy with a GestureDetector.gesture detection on an element\n    if (this.current) {\n      return;\n    }\n\n    this.stopped = false; // holds current session\n\n    this.current = {\n      inst: inst,\n      // reference to GestureDetectorInstance we're working for\n      startEvent: Utils.extend({}, eventData),\n      // start eventData for distances, timing etc\n      lastEvent: false,\n      // last eventData\n      lastCalcEvent: false,\n      // last eventData for calculations.\n      futureCalcEvent: false,\n      // last eventData for calculations.\n      lastCalcData: {},\n      // last lastCalcData\n      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n\n    };\n    this.detect(eventData);\n  },\n\n  /**\n   * GestureDetector.gesture detection\n   * @param {Object} eventData\n   * @return {any}\n   */\n  detect: function detect(eventData) {\n    if (!this.current || this.stopped) {\n      return;\n    } // extend event data with calculations about scale, distance etc\n\n\n    eventData = this.extendEventData(eventData); // GestureDetector instance and instance options\n\n    var inst = this.current.inst,\n        instOptions = inst.options; // call GestureDetector.gesture handlers\n\n    Utils.each(this.gestures, function triggerGesture(gesture) {\n      // only when the instance options have enabled this gesture\n      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {\n        gesture.handler.call(gesture, eventData, inst);\n      }\n    }, this); // store as previous event event\n\n    if (this.current) {\n      this.current.lastEvent = eventData;\n    }\n\n    if (eventData.eventType == EVENT_END) {\n      this.stopDetect();\n    }\n\n    return eventData; // eslint-disable-line consistent-return\n  },\n\n  /**\n   * clear the GestureDetector.gesture vars\n   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected\n   * to stop other GestureDetector.gestures from being fired\n   */\n  stopDetect: function stopDetect() {\n    // clone current data to the store as the previous gesture\n    // used for the double tap gesture, since this is an other gesture detect session\n    this.previous = Utils.extend({}, this.current); // reset the current\n\n    this.current = null;\n    this.stopped = true;\n  },\n\n  /**\n   * calculate velocity, angle and direction\n   * @param {Object} ev\n   * @param {Object} center\n   * @param {Number} deltaTime\n   * @param {Number} deltaX\n   * @param {Number} deltaY\n   */\n  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {\n    var cur = this.current,\n        recalc = false,\n        calcEv = cur.lastCalcEvent,\n        calcData = cur.lastCalcData;\n\n    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {\n      center = calcEv.center;\n      deltaTime = ev.timeStamp - calcEv.timeStamp;\n      deltaX = ev.center.clientX - calcEv.center.clientX;\n      deltaY = ev.center.clientY - calcEv.center.clientY;\n      recalc = true;\n    }\n\n    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {\n      cur.futureCalcEvent = ev;\n    }\n\n    if (!cur.lastCalcEvent || recalc) {\n      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);\n      calcData.angle = Utils.getAngle(center, ev.center);\n      calcData.direction = Utils.getDirection(center, ev.center);\n      cur.lastCalcEvent = cur.futureCalcEvent || ev;\n      cur.futureCalcEvent = ev;\n    }\n\n    ev.velocityX = calcData.velocity.x;\n    ev.velocityY = calcData.velocity.y;\n    ev.interimAngle = calcData.angle;\n    ev.interimDirection = calcData.direction;\n  },\n\n  /**\n   * extend eventData for GestureDetector.gestures\n   * @param {Object} ev\n   * @return {Object} ev\n   */\n  extendEventData: function extendEventData(ev) {\n    var cur = this.current,\n        startEv = cur.startEvent,\n        lastEv = cur.lastEvent || startEv; // update the start touchlist to calculate the scale/rotation\n\n    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {\n      startEv.touches = [];\n      Utils.each(ev.touches, function (touch) {\n        startEv.touches.push({\n          clientX: touch.clientX,\n          clientY: touch.clientY\n        });\n      });\n    }\n\n    var deltaTime = ev.timeStamp - startEv.timeStamp,\n        deltaX = ev.center.clientX - startEv.center.clientX,\n        deltaY = ev.center.clientY - startEv.center.clientY;\n    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);\n    Utils.extend(ev, {\n      startEvent: startEv,\n      deltaTime: deltaTime,\n      deltaX: deltaX,\n      deltaY: deltaY,\n      distance: Utils.getDistance(startEv.center, ev.center),\n      angle: Utils.getAngle(startEv.center, ev.center),\n      direction: Utils.getDirection(startEv.center, ev.center),\n      scale: Utils.getScale(startEv.touches, ev.touches),\n      rotation: Utils.getRotation(startEv.touches, ev.touches)\n    });\n    return ev;\n  },\n\n  /**\n   * register new gesture\n   * @param {Object} gesture object, see `gestures/` for documentation\n   * @return {Array} gestures\n   */\n  register: function register(gesture) {\n    // add an enable gesture options if there is no given\n    var options = gesture.defaults || {};\n\n    if (options[gesture.name] === undefined) {\n      options[gesture.name] = true;\n    } // extend GestureDetector default options with the GestureDetector.gesture options\n\n\n    Utils.extend(GestureDetector.defaults, options, true); // set its index\n\n    gesture.index = gesture.index || 1000; // add GestureDetector.gesture to the list\n\n    this.gestures.push(gesture); // sort the list by index\n\n    this.gestures.sort(function (a, b) {\n      if (a.index < b.index) {\n        return -1;\n      }\n\n      if (a.index > b.index) {\n        return 1;\n      }\n\n      return 0;\n    });\n    return this.gestures;\n  }\n};\n/**\n * @module GestureDetector\n */\n\n/**\n * create new GestureDetector instance\n * all methods should return the instance itself, so it is chainable.\n *\n * @class Instance\n * @constructor\n * @param {HTMLElement} element\n * @param {Object} [options={}] options are merged with `GestureDetector.defaults`\n * @return {GestureDetector.Instance}\n */\n\nGestureDetector.Instance = function (element, options) {\n  var self = this;\n  var listenerOptions = options && options.passive ? {\n    passive: true\n  } : undefined; // setup GestureDetectorJS window events and register all gestures\n  // this also sets up the default options\n\n  setup(listenerOptions);\n  /**\n   * @property element\n   * @type {HTMLElement}\n   */\n\n  this.element = element;\n  /**\n   * @property enabled\n   * @type {Boolean}\n   * @protected\n   */\n\n  this.enabled = true;\n  /**\n   * options, merged with the defaults\n   * options with an _ are converted to camelCase\n   * @property options\n   * @type {Object}\n   */\n\n  Utils.each(options, function (value, name) {\n    delete options[name];\n    options[Utils.toCamelCase(name)] = value;\n  });\n  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});\n  this.options.listenerOptions = listenerOptions; // add some css to the element to prevent the browser from doing its native behavior\n\n  if (this.options.behavior) {\n    Utils.toggleBehavior(this.element, this.options.behavior, true);\n  }\n  /**\n   * event start handler on the element to start the detection\n   * @property eventStartHandler\n   * @type {Object}\n   */\n\n\n  this.eventStartHandler = Event.onTouch(element, EVENT_START, function (ev) {\n    if (self.enabled && ev.eventType == EVENT_START) {\n      Detection.startDetect(self, ev);\n    } else if (ev.eventType == EVENT_TOUCH) {\n      Detection.detect(ev);\n    }\n  }, listenerOptions);\n  /**\n   * keep a list of user event handlers which needs to be removed when calling 'dispose'\n   * @property eventHandlers\n   * @type {Array}\n   */\n\n  this.eventHandlers = [];\n};\n\nGestureDetector.Instance.prototype = {\n  /**\n   * @method on\n   * @signature on(gestures, handler)\n   * @description\n   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]\n   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]\n   * @param {String} gestures\n   *   [en]A space separated list of gestures.[/en]\n   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]\n   * @param {Function} handler\n   *   [en]An event handling function.[/en]\n   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]\n   */\n  on: function onEvent(gestures, handler, opt) {\n    var self = this;\n    Event.on(self.element, gestures, handler, util.extend({}, self.options.listenerOptions, opt), function (type) {\n      self.eventHandlers.push({\n        gesture: type,\n        handler: handler\n      });\n    });\n    return self;\n  },\n\n  /**\n   * @method off\n   * @signature off(gestures, handler)\n   * @description\n   *  [en]Remove an event listener.[/en]\n   *  [ja]イベントリスナーを削除します。[/ja]\n   * @param {String} gestures\n   *   [en]A space separated list of gestures.[/en]\n   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]\n   * @param {Function} handler\n   *   [en]An event handling function.[/en]\n   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]\n   */\n  off: function offEvent(gestures, handler, opt) {\n    var self = this;\n    Event.off(self.element, gestures, handler, util.extend({}, self.options.listenerOptions, opt), function (type) {\n      var index = Utils.inArray(self.eventHandlers, {\n        gesture: type,\n        handler: handler\n      }, true);\n\n      if (index >= 0) {\n        self.eventHandlers.splice(index, 1);\n      }\n    });\n    return self;\n  },\n\n  /**\n   * trigger gesture event\n   * @method trigger\n   * @signature trigger(gesture, eventData)\n   * @param {String} gesture\n   * @param {Object} [eventData]\n   */\n  trigger: function triggerEvent(gesture, eventData) {\n    // optional\n    if (!eventData) {\n      eventData = {};\n    } // create DOM event\n\n\n    var event = GestureDetector.DOCUMENT.createEvent('Event');\n    event.initEvent(gesture, true, true);\n    event.gesture = eventData; // trigger on the target if it is in the instance element,\n    // this is for event delegation tricks\n\n    var element = this.element;\n\n    if (Utils.hasParent(eventData.target, element)) {\n      element = eventData.target;\n    }\n\n    element.dispatchEvent(event);\n    return this;\n  },\n\n  /**\n   * @method enable\n   * @signature enable(state)\n   * @description\n   *  [en]Enable or disable gesture detection.[/en]\n   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]\n   * @param {Boolean} state\n   *   [en]Specify if it should be enabled or not.[/en]\n   *   [ja]有効にするかどうかを指定します。[/ja]\n   */\n  enable: function enable(state) {\n    this.enabled = state;\n    return this;\n  },\n\n  /**\n   * @method dispose\n   * @signature dispose()\n   * @description\n   *  [en]Remove and destroy all event handlers for this instance.[/en]\n   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]\n   */\n  dispose: function dispose() {\n    var i, eh; // undo all changes made by stop_browser_behavior\n\n    Utils.toggleBehavior(this.element, this.options.behavior, false); // unbind all custom event handlers\n\n    for (i = -1; eh = this.eventHandlers[++i];) {\n      // eslint-disable-line no-cond-assign\n      Utils.off(this.element, eh.gesture, eh.handler);\n    }\n\n    this.eventHandlers = []; // unbind the start event listener\n\n    Event.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);\n    return null;\n  }\n};\n/**\n * @module gestures\n */\n\n/**\n * Move with x fingers (default 1) around on the page.\n * Preventing the default browser behavior is a good way to improve feel and working.\n * ````\n *  GestureDetectortime.on(\"drag\", function(ev) {\n *    console.log(ev);\n *    ev.gesture.preventDefault();\n *  });\n * ````\n *\n * @class Drag\n * @static\n */\n\n/**\n * @event drag\n * @param {Object} ev\n */\n\n/**\n * @event dragstart\n * @param {Object} ev\n */\n\n/**\n * @event dragend\n * @param {Object} ev\n */\n\n/**\n * @event drapleft\n * @param {Object} ev\n */\n\n/**\n * @event dragright\n * @param {Object} ev\n */\n\n/**\n * @event dragup\n * @param {Object} ev\n */\n\n/**\n * @event dragdown\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n\n(function (name) {\n  var triggered = false;\n\n  function dragGesture(ev, inst) {\n    var cur = Detection.current; // max touches\n\n    if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {\n      return;\n    }\n\n    switch (ev.eventType) {\n      case EVENT_START:\n        triggered = false;\n        break;\n\n      case EVENT_MOVE:\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if (ev.distance < inst.options.dragMinDistance && cur.name != name) {\n          return;\n        }\n\n        var startCenter = cur.startEvent.center; // we are dragging!\n\n        if (cur.name != name) {\n          cur.name = name;\n\n          if (inst.options.dragDistanceCorrection && ev.distance > 0) {\n            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.\n            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.\n            // It might be useful to save the original start point somewhere\n            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);\n            startCenter.pageX += ev.deltaX * factor;\n            startCenter.pageY += ev.deltaY * factor;\n            startCenter.clientX += ev.deltaX * factor;\n            startCenter.clientY += ev.deltaY * factor; // recalculate event data using new start point\n\n            ev = Detection.extendEventData(ev);\n          }\n        } // lock drag to axis?\n\n\n        if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {\n          ev.dragLockToAxis = true;\n        } // keep direction on the axis that the drag gesture started on\n\n\n        var lastDirection = cur.lastEvent.direction;\n\n        if (ev.dragLockToAxis && lastDirection !== ev.direction) {\n          if (Utils.isVertical(lastDirection)) {\n            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          } else {\n            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          }\n        } // first time, trigger dragstart event\n\n\n        if (!triggered) {\n          inst.trigger(name + 'start', ev);\n          triggered = true;\n        } // trigger events\n\n\n        inst.trigger(name, ev);\n        inst.trigger(name + ev.direction, ev);\n        var isVertical = Utils.isVertical(ev.direction); // block the browser events\n\n        if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {\n          ev.preventDefault();\n        }\n\n        break;\n\n      case EVENT_RELEASE:\n        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {\n          inst.trigger(name + 'end', ev);\n          triggered = false;\n        }\n\n        break;\n\n      case EVENT_END:\n        triggered = false;\n        break;\n    }\n  }\n\n  GestureDetector.gestures.Drag = {\n    name: name,\n    index: 50,\n    handler: dragGesture,\n    defaults: {\n      /**\n       * minimal movement that have to be made before the drag event gets triggered\n       * @property dragMinDistance\n       * @type {Number}\n       * @default 10\n       */\n      dragMinDistance: 10,\n\n      /**\n       * Set dragDistanceCorrection to true to make the starting point of the drag\n       * be calculated from where the drag was triggered, not from where the touch started.\n       * Useful to avoid a jerk-starting drag, which can make fine-adjustments\n       * through dragging difficult, and be visually unappealing.\n       * @property dragDistanceCorrection\n       * @type {Boolean}\n       * @default true\n       */\n      dragDistanceCorrection: true,\n\n      /**\n       * set 0 for unlimited, but this can conflict with transform\n       * @property dragMaxTouches\n       * @type {Number}\n       * @default 1\n       */\n      dragMaxTouches: 1,\n\n      /**\n       * prevent default browser behavior when dragging occurs\n       * be careful with it, it makes the element a blocking element\n       * when you are using the drag gesture, it is a good practice to set this true\n       * @property dragBlockHorizontal\n       * @type {Boolean}\n       * @default false\n       */\n      dragBlockHorizontal: false,\n\n      /**\n       * same as `dragBlockHorizontal`, but for vertical movement\n       * @property dragBlockVertical\n       * @type {Boolean}\n       * @default false\n       */\n      dragBlockVertical: false,\n\n      /**\n       * dragLockToAxis keeps the drag gesture on the axis that it started on,\n       * It disallows vertical directions if the initial direction was horizontal, and vice versa.\n       * @property dragLockToAxis\n       * @type {Boolean}\n       * @default false\n       */\n      dragLockToAxis: false,\n\n      /**\n       * drag lock only kicks in when distance > dragLockMinDistance\n       * This way, locking occurs only when the distance has become large enough to reliably determine the direction\n       * @property dragLockMinDistance\n       * @type {Number}\n       * @default 25\n       */\n      dragLockMinDistance: 25\n    }\n  };\n})('drag');\n/**\n * @module gestures\n */\n\n/**\n * trigger a simple gesture event, so you can do anything in your handler.\n * only usable if you know what your doing...\n *\n * @class Gesture\n * @static\n */\n\n/**\n * @event gesture\n * @param {Object} ev\n */\n\n\nGestureDetector.gestures.Gesture = {\n  name: 'gesture',\n  index: 1337,\n  handler: function releaseGesture(ev, inst) {\n    inst.trigger(this.name, ev);\n  }\n};\n/**\n * @module gestures\n */\n\n/**\n * Touch stays at the same place for x time\n *\n * @class Hold\n * @static\n */\n\n/**\n * @event hold\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n\n(function (name) {\n  var timer;\n\n  function holdGesture(ev, inst) {\n    var options = inst.options,\n        current = Detection.current;\n\n    switch (ev.eventType) {\n      case EVENT_START:\n        clearTimeout(timer); // set the gesture so we can check in the timeout if it still is\n\n        current.name = name; // set timer and if after the timeout it still is hold,\n        // we trigger the hold event\n\n        timer = setTimeout(function () {\n          if (current && current.name == name) {\n            inst.trigger(name, ev);\n          }\n        }, options.holdTimeout);\n        break;\n\n      case EVENT_MOVE:\n        if (ev.distance > options.holdThreshold) {\n          clearTimeout(timer);\n        }\n\n        break;\n\n      case EVENT_RELEASE:\n        clearTimeout(timer);\n        break;\n    }\n  }\n\n  GestureDetector.gestures.Hold = {\n    name: name,\n    index: 10,\n    defaults: {\n      /**\n       * @property holdTimeout\n       * @type {Number}\n       * @default 500\n       */\n      holdTimeout: 500,\n\n      /**\n       * movement allowed while holding\n       * @property holdThreshold\n       * @type {Number}\n       * @default 2\n       */\n      holdThreshold: 2\n    },\n    handler: holdGesture\n  };\n})('hold');\n/**\n * @module gestures\n */\n\n/**\n * when a touch is being released from the page\n *\n * @class Release\n * @static\n */\n\n/**\n * @event release\n * @param {Object} ev\n */\n\n\nGestureDetector.gestures.Release = {\n  name: 'release',\n  index: Infinity,\n  handler: function releaseGesture(ev, inst) {\n    if (ev.eventType == EVENT_RELEASE) {\n      inst.trigger(this.name, ev);\n    }\n  }\n};\n/**\n * @module gestures\n */\n\n/**\n * triggers swipe events when the end velocity is above the threshold\n * for best usage, set `preventDefault` (on the drag gesture) to `true`\n * ````\n *  GestureDetectortime.on(\"dragleft swipeleft\", function(ev) {\n *    console.log(ev);\n *    ev.gesture.preventDefault();\n *  });\n * ````\n *\n * @class Swipe\n * @static\n */\n\n/**\n * @event swipe\n * @param {Object} ev\n */\n\n/**\n * @event swipeleft\n * @param {Object} ev\n */\n\n/**\n * @event swiperight\n * @param {Object} ev\n */\n\n/**\n * @event swipeup\n * @param {Object} ev\n */\n\n/**\n * @event swipedown\n * @param {Object} ev\n */\n\nGestureDetector.gestures.Swipe = {\n  name: 'swipe',\n  index: 40,\n  defaults: {\n    /**\n     * @property swipeMinTouches\n     * @type {Number}\n     * @default 1\n     */\n    swipeMinTouches: 1,\n\n    /**\n     * @property swipeMaxTouches\n     * @type {Number}\n     * @default 1\n     */\n    swipeMaxTouches: 1,\n\n    /**\n     * horizontal swipe velocity\n     * @property swipeVelocityX\n     * @type {Number}\n     * @default 0.6\n     */\n    swipeVelocityX: 0.6,\n\n    /**\n     * vertical swipe velocity\n     * @property swipeVelocityY\n     * @type {Number}\n     * @default 0.6\n     */\n    swipeVelocityY: 0.6\n  },\n  handler: function swipeGesture(ev, inst) {\n    if (ev.eventType == EVENT_RELEASE) {\n      var touches = ev.touches.length,\n          options = inst.options; // max touches\n\n      if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {\n        return;\n      } // when the distance we moved is too small we skip this gesture\n      // or we can be already in dragging\n\n\n      if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {\n        // trigger swipe events\n        inst.trigger(this.name, ev);\n        inst.trigger(this.name + ev.direction, ev);\n      }\n    }\n  }\n};\n/**\n * @module gestures\n */\n\n/**\n * Single tap and a double tap on a place\n *\n * @class Tap\n * @static\n */\n\n/**\n * @event tap\n * @param {Object} ev\n */\n\n/**\n * @event doubletap\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n\n(function (name) {\n  var hasMoved = false;\n\n  function tapGesture(ev, inst) {\n    var options = inst.options,\n        current = Detection.current,\n        prev = Detection.previous,\n        sincePrev,\n        didDoubleTap;\n\n    switch (ev.eventType) {\n      case EVENT_START:\n        hasMoved = false;\n        break;\n\n      case EVENT_MOVE:\n        hasMoved = hasMoved || ev.distance > options.tapMaxDistance;\n        break;\n\n      case EVENT_END:\n        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {\n          // previous gesture, for the double tap since these are two different gesture detections\n          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;\n          didDoubleTap = false; // check if double tap\n\n          if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {\n            inst.trigger('doubletap', ev);\n            didDoubleTap = true;\n          } // do a single tap\n\n\n          if (!didDoubleTap || options.tapAlways) {\n            current.name = name;\n            inst.trigger(current.name, ev);\n          }\n        }\n\n        break;\n    }\n  }\n\n  GestureDetector.gestures.Tap = {\n    name: name,\n    index: 100,\n    handler: tapGesture,\n    defaults: {\n      /**\n       * max time of a tap, this is for the slow tappers\n       * @property tapMaxTime\n       * @type {Number}\n       * @default 250\n       */\n      tapMaxTime: 250,\n\n      /**\n       * max distance of movement of a tap, this is for the slow tappers\n       * @property tapMaxDistance\n       * @type {Number}\n       * @default 10\n       */\n      tapMaxDistance: 10,\n\n      /**\n       * always trigger the `tap` event, even while double-tapping\n       * @property tapAlways\n       * @type {Boolean}\n       * @default true\n       */\n      tapAlways: true,\n\n      /**\n       * max distance between two taps\n       * @property doubleTapDistance\n       * @type {Number}\n       * @default 20\n       */\n      doubleTapDistance: 20,\n\n      /**\n       * max time between two taps\n       * @property doubleTapInterval\n       * @type {Number}\n       * @default 300\n       */\n      doubleTapInterval: 300\n    }\n  };\n})('tap');\n/**\n * @module gestures\n */\n\n/**\n * when a touch is being touched at the page\n *\n * @class Touch\n * @static\n */\n\n/**\n * @event touch\n * @param {Object} ev\n */\n\n\nGestureDetector.gestures.Touch = {\n  name: 'touch',\n  index: -Infinity,\n  defaults: {\n    /**\n     * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,\n     * but it improves gestures like transforming and dragging.\n     * be careful with using this, it can be very annoying for users to be stuck on the page\n     * @property preventDefault\n     * @type {Boolean}\n     * @default false\n     */\n    preventDefault: false,\n\n    /**\n     * disable mouse events, so only touch (or pen!) input triggers events\n     * @property preventMouse\n     * @type {Boolean}\n     * @default false\n     */\n    preventMouse: false\n  },\n  handler: function touchGesture(ev, inst) {\n    if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {\n      ev.stopDetect();\n      return;\n    }\n\n    if (inst.options.preventDefault) {\n      ev.preventDefault();\n    }\n\n    if (ev.eventType == EVENT_TOUCH) {\n      inst.trigger('touch', ev);\n    }\n  }\n};\n/**\n * @module gestures\n */\n\n/**\n * User want to scale or rotate with 2 fingers\n * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the\n * `preventDefault` option.\n *\n * @class Transform\n * @static\n */\n\n/**\n * @event transform\n * @param {Object} ev\n */\n\n/**\n * @event transformstart\n * @param {Object} ev\n */\n\n/**\n * @event transformend\n * @param {Object} ev\n */\n\n/**\n * @event pinchin\n * @param {Object} ev\n */\n\n/**\n * @event pinchout\n * @param {Object} ev\n */\n\n/**\n * @event rotate\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n\n(function (name) {\n  var triggered = false;\n\n  function transformGesture(ev, inst) {\n    switch (ev.eventType) {\n      case EVENT_START:\n        triggered = false;\n        break;\n\n      case EVENT_MOVE:\n        // at least multitouch\n        if (ev.touches.length < 2) {\n          return;\n        }\n\n        var scaleThreshold = Math.abs(1 - ev.scale);\n        var rotationThreshold = Math.abs(ev.rotation); // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n\n        if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {\n          return;\n        } // we are transforming!\n\n\n        Detection.current.name = name; // first time, trigger dragstart event\n\n        if (!triggered) {\n          inst.trigger(name + 'start', ev);\n          triggered = true;\n        }\n\n        inst.trigger(name, ev); // basic transform event\n        // trigger rotate event\n\n        if (rotationThreshold > inst.options.transformMinRotation) {\n          inst.trigger('rotate', ev);\n        } // trigger pinch event\n\n\n        if (scaleThreshold > inst.options.transformMinScale) {\n          inst.trigger('pinch', ev);\n          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);\n        }\n\n        break;\n\n      case EVENT_RELEASE:\n        if (triggered && ev.changedLength < 2) {\n          inst.trigger(name + 'end', ev);\n          triggered = false;\n        }\n\n        break;\n    }\n  }\n\n  GestureDetector.gestures.Transform = {\n    name: name,\n    index: 45,\n    defaults: {\n      /**\n       * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n       * @property transformMinScale\n       * @type {Number}\n       * @default 0.01\n       */\n      transformMinScale: 0.01,\n\n      /**\n       * rotation in degrees\n       * @property transformMinRotation\n       * @type {Number}\n       * @default 1\n       */\n      transformMinRotation: 1\n    },\n    handler: transformGesture\n  };\n})('transform');\n\nexport default GestureDetector;","map":{"version":3,"names":["util","Event","Utils","Detection","PointerEvent","GestureDetector","element","options","Instance","defaults","behavior","touchAction","touchCallout","contentZooming","userDrag","tapHighlightColor","DOCUMENT","document","HAS_POINTEREVENTS","navigator","pointerEnabled","msPointerEnabled","HAS_TOUCHEVENTS","window","IS_MOBILE","test","userAgent","NO_MOUSEEVENTS","CALCULATE_INTERVAL","EVENT_TYPES","DIRECTION_DOWN","DIRECTION_LEFT","DIRECTION_UP","DIRECTION_RIGHT","POINTER_MOUSE","POINTER_TOUCH","POINTER_PEN","EVENT_START","EVENT_MOVE","EVENT_END","EVENT_RELEASE","EVENT_TOUCH","READY","plugins","gestures","setup","opts","determineEventTypes","each","gesture","register","onTouch","detect","utils","extend","dest","src","merge","key","Object","prototype","hasOwnProperty","call","undefined","on","type","handler","opt","addEventListener","off","removeEventListener","obj","iterator","context","i","len","forEach","length","inStr","find","indexOf","inArray","deep","keys","every","toArray","Array","slice","hasParent","node","parent","parentNode","getCenter","touches","pageX","pageY","clientX","clientY","min","Math","max","touch","push","apply","getVelocity","deltaTime","deltaX","deltaY","x","abs","y","getAngle","touch1","touch2","atan2","PI","getDirection","getDistance","sqrt","getScale","start","end","getRotation","isVertical","direction","setPrefixedCss","prop","value","toggle","prefixes","toCamelCase","p","toUpperCase","style","toggleBehavior","props","falseFn","userSelect","onselectstart","ondragstart","str","replace","s","event","preventMouseEvents","started","shouldDetect","hook","types","split","eventType","self","onTouchHandler","ev","srcType","toLowerCase","isPointer","isMouse","triggerType","button","buttons","matchType","updatePointer","doDetect","reset","touchList","getTouchList","touchListLength","triggerChange","trigger","changedLength","changedTouches","evData","collectEventData","identifiers","concat","identifier","pointerType","center","timeStamp","Date","now","target","srcEvent","preventDefault","preventManipulation","stopPropagation","stopDetect","pointers","touchlist","pointer","pointerEvent","pointerId","pt","MSPOINTER_TYPE_MOUSE","MSPOINTER_TYPE_TOUCH","MSPOINTER_TYPE_PEN","resetList","detection","current","previous","stopped","startDetect","inst","eventData","startEvent","lastEvent","lastCalcEvent","futureCalcEvent","lastCalcData","name","extendEventData","instOptions","triggerGesture","enabled","getCalculatedData","cur","recalc","calcEv","calcData","velocity","angle","velocityX","velocityY","interimAngle","interimDirection","startEv","lastEv","distance","scale","rotation","index","sort","a","b","listenerOptions","passive","eventStartHandler","eventHandlers","onEvent","offEvent","splice","triggerEvent","createEvent","initEvent","dispatchEvent","enable","state","dispose","eh","triggered","dragGesture","dragMaxTouches","dragMinDistance","startCenter","dragDistanceCorrection","factor","dragLockToAxis","dragLockMinDistance","lastDirection","dragBlockVertical","dragBlockHorizontal","Drag","Gesture","releaseGesture","timer","holdGesture","clearTimeout","setTimeout","holdTimeout","holdThreshold","Hold","Release","Infinity","Swipe","swipeMinTouches","swipeMaxTouches","swipeVelocityX","swipeVelocityY","swipeGesture","hasMoved","tapGesture","prev","sincePrev","didDoubleTap","tapMaxDistance","tapMaxTime","doubleTapInterval","doubleTapDistance","tapAlways","Tap","Touch","preventMouse","touchGesture","transformGesture","scaleThreshold","rotationThreshold","transformMinScale","transformMinRotation","Transform"],"sources":["C:/React-app/test/ui/node_modules/onsenui/esm/ons/gesture-detector.js"],"sourcesContent":["/*\n * Gesture detector library that forked from github.com/EightMedia/hammer.js.\n */\n\n'use strict';\n\nimport util from './util.js';\n\nvar Event, Utils, Detection, PointerEvent;\n\n/**\n * @object ons.GestureDetector\n * @category gesture\n * @description\n *   [en]Utility class for gesture detection.[/en]\n *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]\n */\n\n/**\n * @method constructor\n * @signature constructor(element[, options])\n * @description\n *  [en]Create a new GestureDetector instance.[/en]\n *  [ja]GestureDetectorのインスタンスを生成します。[/ja]\n * @param {Element} element\n *   [en]Name of the event.[/en]\n *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]\n * @param {Object} [options]\n *   [en]Options object.[/en]\n *   [ja]オプションを指定します。[/ja]\n * @return {ons.GestureDetector.Instance}\n */\nvar GestureDetector = function GestureDetector(element, options) {\n  return new GestureDetector.Instance(element, options || {});\n};\n\n\n/**\n * default settings.\n * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled\n * by setting it's name (like `swipe`) to false.\n * You can set the defaults for all instances by changing this object before creating an instance.\n * @example\n * ````\n *  GestureDetector.defaults.drag = false;\n *  GestureDetector.defaults.behavior.touchAction = 'pan-y';\n *  delete GestureDetector.defaults.behavior.userSelect;\n * ````\n * @property defaults\n * @type {Object}\n */\nGestureDetector.defaults = {\n  behavior: {\n    // userSelect: 'none', // Also disables selection in `input` children\n    touchAction: 'pan-y',\n    touchCallout: 'none',\n    contentZooming: 'none',\n    userDrag: 'none',\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n};\n\n/**\n * GestureDetector document where the base events are added at\n * @property DOCUMENT\n * @type {HTMLElement}\n * @default window.document\n */\nGestureDetector.DOCUMENT = document;\n\n/**\n * detect support for pointer events\n * @property HAS_POINTEREVENTS\n * @type {Boolean}\n */\nGestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;\n\n/**\n * detect support for touch events\n * @property HAS_TOUCHEVENTS\n * @type {Boolean}\n */\nGestureDetector.HAS_TOUCHEVENTS = ('ontouchstart' in window);\n\n/**\n * detect mobile browsers\n * @property IS_MOBILE\n * @type {Boolean}\n */\nGestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);\n\n/**\n * detect if we want to support mouseevents at all\n * @property NO_MOUSEEVENTS\n * @type {Boolean}\n */\nGestureDetector.NO_MOUSEEVENTS = (GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE) || GestureDetector.HAS_POINTEREVENTS;\n\n/**\n * interval in which GestureDetector recalculates current velocity/direction/angle in ms\n * @property CALCULATE_INTERVAL\n * @type {Number}\n * @default 25\n */\nGestureDetector.CALCULATE_INTERVAL = 25;\n\n/**\n * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`\n * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)\n * @property EVENT_TYPES\n * @private\n * @writeOnce\n * @type {Object}\n */\nvar EVENT_TYPES = {};\n\n/**\n * direction strings, for safe comparisons\n * @property DIRECTION_DOWN|LEFT|UP|RIGHT\n * @final\n * @type {String}\n * @default 'down' 'left' 'up' 'right'\n */\nvar DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';\nvar DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';\nvar DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';\nvar DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';\n\n/**\n * pointertype strings, for safe comparisons\n * @property POINTER_MOUSE|TOUCH|PEN\n * @final\n * @type {String}\n * @default 'mouse' 'touch' 'pen'\n */\nvar POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';\nvar POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';\nvar POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';\n\n/**\n * eventtypes\n * @property EVENT_START|MOVE|END|RELEASE|TOUCH\n * @final\n * @type {String}\n * @default 'start' 'change' 'move' 'end' 'release' 'touch'\n */\nvar EVENT_START = GestureDetector.EVENT_START = 'start';\nvar EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';\nvar EVENT_END = GestureDetector.EVENT_END = 'end';\nvar EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';\nvar EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';\n\n/**\n * if the window events are set...\n * @property READY\n * @writeOnce\n * @type {Boolean}\n * @default false\n */\nGestureDetector.READY = false;\n\n/**\n * plugins namespace\n * @property plugins\n * @type {Object}\n */\nGestureDetector.plugins = GestureDetector.plugins || {};\n\n/**\n * gestures namespace\n * see `/gestures` for the definitions\n * @property gestures\n * @type {Object}\n */\nGestureDetector.gestures = GestureDetector.gestures || {};\n\n/**\n * setup events to detect gestures on the document\n * this function is called when creating an new instance\n * @private\n */\nfunction setup(opts) {\n  if (GestureDetector.READY) {\n    return;\n  }\n\n  // find what eventtypes we add listeners to\n  Event.determineEventTypes();\n\n  // Register all gestures inside GestureDetector.gestures\n  Utils.each(GestureDetector.gestures, function(gesture) {\n    Detection.register(gesture);\n  });\n\n  // Add touch events on the document\n  Event.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect, opts);\n  Event.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect, opts);\n\n  // GestureDetector is ready...!\n  GestureDetector.READY = true;\n}\n\n/**\n * @module GestureDetector\n *\n * @class Utils\n * @static\n */\nUtils = GestureDetector.utils = {\n  /**\n   * extend method, could also be used for cloning when `dest` is an empty object.\n   * changes the dest object\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]  do a merge\n   * @return {Object} dest\n   */\n  extend: function extend(dest, src, merge) {\n    for (var key in src) {\n      if (Object.prototype.hasOwnProperty.call(src, key) && (dest[key] === undefined || !merge)) {\n        dest[key] = src[key];\n      }\n    }\n    return dest;\n  },\n\n  /**\n   * simple addEventListener wrapper\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   */\n  on: function on(element, type, handler, opt) {\n    util.addEventListener(element, type, handler, opt, true);\n  },\n\n  /**\n   * simple removeEventListener wrapper\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   */\n  off: function off(element, type, handler, opt) {\n    util.removeEventListener(element, type, handler, opt, true);\n  },\n\n  /**\n   * forEach over arrays and objects\n   * @param {Object|Array} obj\n   * @param {Function} iterator\n   * @param {any} iterator.item\n   * @param {Number} iterator.index\n   * @param {Object|Array} iterator.obj the source object\n   * @param {Object} context value to use as `this` in the iterator\n   */\n  each: function each(obj, iterator, context) {\n    var i, len;\n\n    // native forEach on arrays\n    if ('forEach' in obj) {\n      obj.forEach(iterator, context);\n      // arrays\n    } else if (obj.length !== undefined) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        if (iterator.call(context, obj[i], i, obj) === false) {\n          return;\n        }\n      }\n      // objects\n    } else {\n      for (i in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, i) &&\n          iterator.call(context, obj[i], i, obj) === false) {\n          return;\n        }\n      }\n    }\n  },\n\n  /**\n   * find if a string contains the string using indexOf\n   * @param {String} src\n   * @param {String} find\n   * @return {Boolean} found\n   */\n  inStr: function inStr(src, find) {\n    return src.indexOf(find) > -1;\n  },\n\n  /**\n   * find if a array contains the object using indexOf or a simple polyfill\n   * @param {String} src\n   * @param {String} find\n   * @return {Boolean|Number} false when not found, or the index\n   */\n  inArray: function inArray(src, find, deep) {\n    if (deep) {\n      for (var i = 0, len = src.length; i < len; i++) { // Array.findIndex\n        if (Object.keys(find).every(function(key) { return src[i][key] === find[key]; })) {\n          return i;\n        }\n      }\n      return -1;\n    }\n\n    if (src.indexOf) {\n      return src.indexOf(find);\n    } else {\n      for (var i = 0, len = src.length; i < len; i++) {\n        if (src[i] === find) {\n          return i;\n        }\n      }\n      return -1;\n    }\n  },\n\n  /**\n   * convert an array-like object (`arguments`, `touchlist`) to an array\n   * @param {Object} obj\n   * @return {Array}\n   */\n  toArray: function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  },\n\n  /**\n   * find if a node is in the given parent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n  hasParent: function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  },\n\n  /**\n   * get the center of all the touches\n   * @param {Array} touches\n   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties\n   */\n  getCenter: function getCenter(touches) {\n    var pageX = [],\n        pageY = [],\n        clientX = [],\n        clientY = [],\n        min = Math.min,\n        max = Math.max;\n\n    // no need to loop when only one touch\n    if (touches.length === 1) {\n      return {\n        pageX: touches[0].pageX,\n        pageY: touches[0].pageY,\n        clientX: touches[0].clientX,\n        clientY: touches[0].clientY\n      };\n    }\n\n    Utils.each(touches, function(touch) {\n      pageX.push(touch.pageX);\n      pageY.push(touch.pageY);\n      clientX.push(touch.clientX);\n      clientY.push(touch.clientY);\n    });\n\n    return {\n      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,\n      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,\n      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,\n      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2\n    };\n  },\n\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} deltaX\n   * @param {Number} deltaY\n   * @return {Object} velocity `x` and `y`\n   */\n  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {\n    return {\n      x: Math.abs(deltaX / deltaTime) || 0,\n      y: Math.abs(deltaY / deltaTime) || 0\n    };\n  },\n\n  /**\n   * calculate the angle between two coordinates\n   * @param {Touch} touch1\n   * @param {Touch} touch2\n   * @return {Number} angle\n   */\n  getAngle: function getAngle(touch1, touch2) {\n    var x = touch2.clientX - touch1.clientX,\n        y = touch2.clientY - touch1.clientY;\n\n    return Math.atan2(y, x) * 180 / Math.PI;\n  },\n\n  /**\n   * do a small comparison to get the direction between two touches.\n   * @param {Touch} touch1\n   * @param {Touch} touch2\n   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`\n   */\n  getDirection: function getDirection(touch1, touch2) {\n    var x = Math.abs(touch1.clientX - touch2.clientX),\n        y = Math.abs(touch1.clientY - touch2.clientY);\n\n    if (x >= y) {\n      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  },\n\n  /**\n   * calculate the distance between two touches\n   * @param {Touch}touch1\n   * @param {Touch} touch2\n   * @return {Number} distance\n   */\n  getDistance: function getDistance(touch1, touch2) {\n    var x = touch2.clientX - touch1.clientX,\n        y = touch2.clientY - touch1.clientY;\n\n    return Math.sqrt((x * x) + (y * y));\n  },\n\n  /**\n   * calculate the scale factor between two touchLists\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of touches\n   * @param {Array} end array of touches\n   * @return {Number} scale\n   */\n  getScale: function getScale(start, end) {\n    // need two fingers...\n    if (start.length >= 2 && end.length >= 2) {\n      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);\n    }\n    return 1;\n  },\n\n  /**\n   * calculate the rotation degrees between two touchLists\n   * @param {Array} start array of touches\n   * @param {Array} end array of touches\n   * @return {Number} rotation\n   */\n  getRotation: function getRotation(start, end) {\n    // need two fingers\n    if (start.length >= 2 && end.length >= 2) {\n      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);\n    }\n    return 0;\n  },\n\n  /**\n   * find out if the direction is vertical   *\n   * @param {String} direction matches `DIRECTION_UP|DOWN`\n   * @return {Boolean} is_vertical\n   */\n  isVertical: function isVertical(direction) {\n    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;\n  },\n\n  /**\n   * set css properties with their prefixes\n   * @param {HTMLElement} element\n   * @param {String} prop\n   * @param {String} value\n   * @param {Boolean} [toggle=true]\n   * @return {Boolean}\n   */\n  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {\n    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];\n    prop = Utils.toCamelCase(prop);\n\n    for (var i = 0; i < prefixes.length; i++) {\n      var p = prop;\n      // prefixes\n      if (prefixes[i]) {\n        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);\n      }\n\n      // test the style\n      if (p in element.style) {\n        element.style[p] = (toggle === null || toggle) && value || '';\n        break;\n      }\n    }\n  },\n\n  /**\n   * toggle browser default behavior by setting css properties.\n   * `userSelect='none'` also sets `element.onselectstart` to false\n   * `userDrag='none'` also sets `element.ondragstart` to false\n   *\n   * @param {HtmlElement} element\n   * @param {Object} props\n   * @param {Boolean} [toggle=true]\n   */\n  toggleBehavior: function toggleBehavior(element, props, toggle) {\n    if (!props || !element || !element.style) {\n      return;\n    }\n\n    // set the css properties\n    Utils.each(props, function(value, prop) {\n      Utils.setPrefixedCss(element, prop, value, toggle);\n    });\n\n    var falseFn = toggle && function() {\n      return false;\n    };\n\n    // also the disable onselectstart\n    if (props.userSelect == 'none') {\n      element.onselectstart = falseFn;\n    }\n    // and disable ondragstart\n    if (props.userDrag == 'none') {\n      element.ondragstart = falseFn;\n    }\n  },\n\n  /**\n   * convert a string with underscores to camelCase\n   * so prevent_default becomes preventDefault\n   * @param {String} str\n   * @return {String} camelCaseStr\n   */\n  toCamelCase: function toCamelCase(str) {\n    return str.replace(/[_-]([a-z])/g, function(s) {\n      return s[1].toUpperCase();\n    });\n  }\n};\n\n\n/**\n * @module GestureDetector\n */\n/**\n * @class Event\n * @static\n */\nEvent = GestureDetector.event = {\n  /**\n   * when touch events have been fired, this is true\n   * this is used to stop mouse events\n   * @property prevent_mouseevents\n   * @private\n   * @type {Boolean}\n   */\n  preventMouseEvents: false,\n\n  /**\n   * if EVENT_START has been fired\n   * @property started\n   * @private\n   * @type {Boolean}\n   */\n  started: false,\n\n  /**\n   * when the mouse is hold down, this is true\n   * @property should_detect\n   * @private\n   * @type {Boolean}\n   */\n  shouldDetect: false,\n\n  /**\n   * simple event binder with a hook and support for multiple types\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   * @param {Object} [opt]\n   * @param {Function} [hook]\n   * @param {Object} hook.type\n   */\n  on: function on(element, type, handler, opt, hook) {\n    var types = type.split(' ');\n    Utils.each(types, function(type) {\n      Utils.on(element, type, handler, opt);\n      hook && hook(type);\n    });\n  },\n\n  /**\n   * simple event unbinder with a hook and support for multiple types\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   * @param {Object} [opt]\n   * @param {Function} [hook]\n   * @param {Object} hook.type\n   */\n  off: function off(element, type, handler, opt, hook) {\n    var types = type.split(' ');\n    Utils.each(types, function(type) {\n      Utils.off(element, type, handler, opt);\n      hook && hook(type);\n    });\n  },\n\n  /**\n   * the core touch event handler.\n   * this finds out if we should to detect gestures\n   * @param {HTMLElement} element\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Function} handler\n   * @return onTouchHandler {Function} the core event handler\n   */\n  onTouch: function onTouch(element, eventType, handler, opt) {\n    var self = this;\n\n    var onTouchHandler = function onTouchHandler(ev) {\n      var srcType = ev.type.toLowerCase(),\n          isPointer = GestureDetector.HAS_POINTEREVENTS,\n          isMouse = Utils.inStr(srcType, 'mouse'),\n          triggerType;\n\n      // if we are in a mouseevent, but there has been a touchevent triggered in this session\n      // we want to do nothing. simply break out of the event.\n      if (isMouse && self.preventMouseEvents) {\n        return;\n\n        // mousebutton must be down\n      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {\n        self.preventMouseEvents = false;\n        self.shouldDetect = true;\n      } else if (isPointer && eventType == EVENT_START) {\n        self.shouldDetect = (ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev));\n        // just a valid start event, but no mouse\n      } else if (!isMouse && eventType == EVENT_START) {\n        self.preventMouseEvents = true;\n        self.shouldDetect = true;\n      }\n\n      // update the pointer event before entering the detection\n      if (isPointer && eventType != EVENT_END) {\n        PointerEvent.updatePointer(eventType, ev);\n      }\n\n      // we are in a touch/down state, so allowed detection of gestures\n      if (self.shouldDetect) {\n        triggerType = self.doDetect.call(self, ev, eventType, element, handler);\n      }\n\n      // ...and we are done with the detection\n      // so reset everything to start each detection totally fresh\n      if (triggerType == EVENT_END) {\n        self.preventMouseEvents = false;\n        self.shouldDetect = false;\n        PointerEvent.reset();\n        // update the pointerevent object after the detection\n      }\n\n      if (isPointer && eventType == EVENT_END) {\n        PointerEvent.updatePointer(eventType, ev);\n      }\n    };\n\n    this.on(element, EVENT_TYPES[eventType], onTouchHandler, opt);\n    return onTouchHandler;\n  },\n\n  /**\n   * the core detection method\n   * this finds out what GestureDetector-touch-events to trigger\n   * @param {Object} ev\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {HTMLElement} element\n   * @param {Function} handler\n   * @return {String} triggerType matches `EVENT_START|MOVE|END`\n   */\n  doDetect: function doDetect(ev, eventType, element, handler) {\n    var touchList = this.getTouchList(ev, eventType);\n    var touchListLength = touchList.length;\n    var triggerType = eventType;\n    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin\n    var changedLength = touchListLength;\n\n    // at each touchstart-like event we want also want to trigger a TOUCH event...\n    if (eventType == EVENT_START) {\n      triggerChange = EVENT_TOUCH;\n      // ...the same for a touchend-like event\n    } else if (eventType == EVENT_END) {\n      triggerChange = EVENT_RELEASE;\n\n      // keep track of how many touches have been removed\n      changedLength = touchList.length - ((ev.changedTouches) ? ev.changedTouches.length : 1);\n    }\n\n    // after there are still touches on the screen,\n    // we just want to trigger a MOVE event. so change the START or END to a MOVE\n    // but only after detection has been started, the first time we actually want a START\n    if (changedLength > 0 && this.started) {\n      triggerType = EVENT_MOVE;\n    }\n\n    // detection has been started, we keep track of this, see above\n    this.started = true;\n\n    // generate some event data, some basic information\n    var evData = this.collectEventData(element, triggerType, touchList, ev);\n\n    // trigger the triggerType event before the change (TOUCH, RELEASE) events\n    // but the END event should be at last\n    if (eventType != EVENT_END) {\n      handler.call(Detection, evData);\n    }\n\n    // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed\n    if (triggerChange) {\n      evData.changedLength = changedLength;\n      evData.eventType = triggerChange;\n\n      handler.call(Detection, evData);\n\n      evData.eventType = triggerType;\n      delete evData.changedLength;\n    }\n\n    // trigger the END event\n    if (triggerType == EVENT_END) {\n      handler.call(Detection, evData);\n\n      // ...and we are done with the detection\n      // so reset everything to start each detection totally fresh\n      this.started = false;\n    }\n\n    return triggerType;\n  },\n\n  /**\n   * we have different events for each device/browser\n   * determine what we need and set them in the EVENT_TYPES constant\n   * the `onTouch` method is bind to these properties.\n   * @return {Object} events\n   */\n  determineEventTypes: function determineEventTypes() {\n    var types;\n    if (GestureDetector.HAS_POINTEREVENTS) {\n      if (window.PointerEvent) {\n        types = [\n          'pointerdown',\n          'pointermove',\n          'pointerup pointercancel lostpointercapture'\n        ];\n      } else {\n        types = [\n          'MSPointerDown',\n          'MSPointerMove',\n          'MSPointerUp MSPointerCancel MSLostPointerCapture'\n        ];\n      }\n    } else if (GestureDetector.NO_MOUSEEVENTS) {\n      types = [\n        'touchstart',\n        'touchmove',\n        'touchend touchcancel'\n      ];\n    } else {\n      types = [\n        'touchstart mousedown',\n        'touchmove mousemove',\n        'touchend touchcancel mouseup'\n      ];\n    }\n\n    EVENT_TYPES[EVENT_START] = types[0];\n    EVENT_TYPES[EVENT_MOVE] = types[1];\n    EVENT_TYPES[EVENT_END] = types[2];\n    return EVENT_TYPES;\n  },\n\n  /**\n   * create touchList depending on the event\n   * @param {Object} ev\n   * @param {String} eventType\n   * @return {Array} touches\n   */\n  getTouchList: function getTouchList(ev, eventType) {\n    // get the fake pointerEvent touchlist\n    if (GestureDetector.HAS_POINTEREVENTS) {\n      return PointerEvent.getTouchList();\n    }\n\n    // get the touchlist\n    if (ev.touches) {\n      if (eventType == EVENT_MOVE) {\n        return ev.touches;\n      }\n\n      var identifiers = [];\n      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));\n      var touchList = [];\n\n      Utils.each(concat, function(touch) {\n        if (Utils.inArray(identifiers, touch.identifier) === -1) {\n          touchList.push(touch);\n        }\n        identifiers.push(touch.identifier);\n      });\n\n      return touchList;\n    }\n\n    // make fake touchList from mouse position\n    ev.identifier = 1;\n    return [ev];\n  },\n\n  /**\n   * collect basic event data\n   * @param {HTMLElement} element\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Array} touches\n   * @param {Object} ev\n   * @return {Object} ev\n   */\n  collectEventData: function collectEventData(element, eventType, touches, ev) {\n    // find out pointerType\n    var pointerType = POINTER_TOUCH;\n    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {\n      pointerType = POINTER_MOUSE;\n    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {\n      pointerType = POINTER_PEN;\n    }\n\n    return {\n      center: Utils.getCenter(touches),\n      timeStamp: Date.now(),\n      target: ev.target,\n      touches: touches,\n      eventType: eventType,\n      pointerType: pointerType,\n      srcEvent: ev,\n\n      /**\n       * prevent the browser default actions\n       * mostly used to disable scrolling of the browser\n       */\n      preventDefault: function() {\n        var srcEvent = this.srcEvent;\n        srcEvent.preventManipulation && srcEvent.preventManipulation();\n        srcEvent.preventDefault && srcEvent.preventDefault();\n      },\n\n      /**\n       * stop bubbling the event up to its parents\n       */\n      stopPropagation: function() {\n        this.srcEvent.stopPropagation();\n      },\n\n      /**\n       * immediately stop gesture detection\n       * might be useful after a swipe was detected\n       * @return {*}\n       */\n      stopDetect: function() {\n        return Detection.stopDetect();\n      }\n    };\n  }\n};\n\n\n/**\n * @module GestureDetector\n *\n * @class PointerEvent\n * @static\n */\nPointerEvent = GestureDetector.PointerEvent = {\n  /**\n   * holds all pointers, by `identifier`\n   * @property pointers\n   * @type {Object}\n   */\n  pointers: {},\n\n  /**\n   * get the pointers as an array\n   * @return {Array} touchlist\n   */\n  getTouchList: function getTouchList() {\n    var touchlist = [];\n    // we can use forEach since pointerEvents only is in IE10\n    Utils.each(this.pointers, function(pointer) {\n      touchlist.push(pointer);\n    });\n    return touchlist;\n  },\n\n  /**\n   * update the position of a pointer\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Object} pointerEvent\n   */\n  updatePointer: function updatePointer(eventType, pointerEvent) {\n    if (eventType == EVENT_END || (eventType != EVENT_END && pointerEvent.buttons !== 1)) {\n      delete this.pointers[pointerEvent.pointerId];\n    } else {\n      pointerEvent.identifier = pointerEvent.pointerId;\n      this.pointers[pointerEvent.pointerId] = pointerEvent;\n    }\n  },\n\n  /**\n   * check if ev matches pointertype\n   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`\n   * @param {PointerEvent} ev\n   */\n  matchType: function matchType(pointerType, ev) {\n    if (!ev.pointerType) {\n      return false;\n    }\n\n    var pt = ev.pointerType,\n        types = {};\n\n    types[POINTER_MOUSE] = (pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE));\n    types[POINTER_TOUCH] = (pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH));\n    types[POINTER_PEN] = (pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN));\n    return types[pointerType];\n  },\n\n  /**\n   * reset the stored pointers\n   */\n  reset: function resetList() {\n    this.pointers = {};\n  }\n};\n\n\n/**\n * @module GestureDetector\n *\n * @class Detection\n * @static\n */\nDetection = GestureDetector.detection = {\n  // contains all registered GestureDetector.gestures in the correct order\n  gestures: [],\n\n  // data of the current GestureDetector.gesture detection session\n  current: null,\n\n  // the previous GestureDetector.gesture session data\n  // is a full clone of the previous gesture.current object\n  previous: null,\n\n  // when this becomes true, no gestures are fired\n  stopped: false,\n\n  /**\n   * start GestureDetector.gesture detection\n   * @param {GestureDetector.Instance} inst\n   * @param {Object} eventData\n   */\n  startDetect: function startDetect(inst, eventData) {\n    // already busy with a GestureDetector.gesture detection on an element\n    if (this.current) {\n      return;\n    }\n\n    this.stopped = false;\n\n    // holds current session\n    this.current = {\n      inst: inst, // reference to GestureDetectorInstance we're working for\n      startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc\n      lastEvent: false, // last eventData\n      lastCalcEvent: false, // last eventData for calculations.\n      futureCalcEvent: false, // last eventData for calculations.\n      lastCalcData: {}, // last lastCalcData\n      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n    };\n\n    this.detect(eventData);\n  },\n\n  /**\n   * GestureDetector.gesture detection\n   * @param {Object} eventData\n   * @return {any}\n   */\n  detect: function detect(eventData) {\n    if (!this.current || this.stopped) {\n      return;\n    }\n\n    // extend event data with calculations about scale, distance etc\n    eventData = this.extendEventData(eventData);\n\n    // GestureDetector instance and instance options\n    var inst = this.current.inst,\n        instOptions = inst.options;\n\n    // call GestureDetector.gesture handlers\n    Utils.each(this.gestures, function triggerGesture(gesture) {\n      // only when the instance options have enabled this gesture\n      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {\n        gesture.handler.call(gesture, eventData, inst);\n      }\n    }, this);\n\n    // store as previous event event\n    if (this.current) {\n      this.current.lastEvent = eventData;\n    }\n\n    if (eventData.eventType == EVENT_END) {\n      this.stopDetect();\n    }\n\n    return eventData; // eslint-disable-line consistent-return\n  },\n\n  /**\n   * clear the GestureDetector.gesture vars\n   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected\n   * to stop other GestureDetector.gestures from being fired\n   */\n  stopDetect: function stopDetect() {\n    // clone current data to the store as the previous gesture\n    // used for the double tap gesture, since this is an other gesture detect session\n    this.previous = Utils.extend({}, this.current);\n\n    // reset the current\n    this.current = null;\n    this.stopped = true;\n  },\n\n  /**\n   * calculate velocity, angle and direction\n   * @param {Object} ev\n   * @param {Object} center\n   * @param {Number} deltaTime\n   * @param {Number} deltaX\n   * @param {Number} deltaY\n   */\n  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {\n    var cur = this.current,\n        recalc = false,\n        calcEv = cur.lastCalcEvent,\n        calcData = cur.lastCalcData;\n\n    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {\n      center = calcEv.center;\n      deltaTime = ev.timeStamp - calcEv.timeStamp;\n      deltaX = ev.center.clientX - calcEv.center.clientX;\n      deltaY = ev.center.clientY - calcEv.center.clientY;\n      recalc = true;\n    }\n\n    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {\n      cur.futureCalcEvent = ev;\n    }\n\n    if (!cur.lastCalcEvent || recalc) {\n      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);\n      calcData.angle = Utils.getAngle(center, ev.center);\n      calcData.direction = Utils.getDirection(center, ev.center);\n\n      cur.lastCalcEvent = cur.futureCalcEvent || ev;\n      cur.futureCalcEvent = ev;\n    }\n\n    ev.velocityX = calcData.velocity.x;\n    ev.velocityY = calcData.velocity.y;\n    ev.interimAngle = calcData.angle;\n    ev.interimDirection = calcData.direction;\n  },\n\n  /**\n   * extend eventData for GestureDetector.gestures\n   * @param {Object} ev\n   * @return {Object} ev\n   */\n  extendEventData: function extendEventData(ev) {\n    var cur = this.current,\n        startEv = cur.startEvent,\n        lastEv = cur.lastEvent || startEv;\n\n    // update the start touchlist to calculate the scale/rotation\n    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {\n      startEv.touches = [];\n      Utils.each(ev.touches, function(touch) {\n        startEv.touches.push({\n          clientX: touch.clientX,\n          clientY: touch.clientY\n        });\n      });\n    }\n\n    var deltaTime = ev.timeStamp - startEv.timeStamp,\n        deltaX = ev.center.clientX - startEv.center.clientX,\n        deltaY = ev.center.clientY - startEv.center.clientY;\n\n    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);\n\n    Utils.extend(ev, {\n      startEvent: startEv,\n\n      deltaTime: deltaTime,\n      deltaX: deltaX,\n      deltaY: deltaY,\n\n      distance: Utils.getDistance(startEv.center, ev.center),\n      angle: Utils.getAngle(startEv.center, ev.center),\n      direction: Utils.getDirection(startEv.center, ev.center),\n      scale: Utils.getScale(startEv.touches, ev.touches),\n      rotation: Utils.getRotation(startEv.touches, ev.touches)\n    });\n\n    return ev;\n  },\n\n  /**\n   * register new gesture\n   * @param {Object} gesture object, see `gestures/` for documentation\n   * @return {Array} gestures\n   */\n  register: function register(gesture) {\n    // add an enable gesture options if there is no given\n    var options = gesture.defaults || {};\n    if (options[gesture.name] === undefined) {\n      options[gesture.name] = true;\n    }\n\n    // extend GestureDetector default options with the GestureDetector.gesture options\n    Utils.extend(GestureDetector.defaults, options, true);\n\n    // set its index\n    gesture.index = gesture.index || 1000;\n\n    // add GestureDetector.gesture to the list\n    this.gestures.push(gesture);\n\n    // sort the list by index\n    this.gestures.sort(function(a, b) {\n      if (a.index < b.index) {\n        return -1;\n      }\n      if (a.index > b.index) {\n        return 1;\n      }\n      return 0;\n    });\n\n    return this.gestures;\n  }\n};\n\n\n/**\n * @module GestureDetector\n */\n\n/**\n * create new GestureDetector instance\n * all methods should return the instance itself, so it is chainable.\n *\n * @class Instance\n * @constructor\n * @param {HTMLElement} element\n * @param {Object} [options={}] options are merged with `GestureDetector.defaults`\n * @return {GestureDetector.Instance}\n */\nGestureDetector.Instance = function(element, options) {\n  var self = this;\n  var listenerOptions = (options && options.passive) ? { passive: true } : undefined;\n\n  // setup GestureDetectorJS window events and register all gestures\n  // this also sets up the default options\n  setup(listenerOptions);\n\n  /**\n   * @property element\n   * @type {HTMLElement}\n   */\n  this.element = element;\n\n  /**\n   * @property enabled\n   * @type {Boolean}\n   * @protected\n   */\n  this.enabled = true;\n\n  /**\n   * options, merged with the defaults\n   * options with an _ are converted to camelCase\n   * @property options\n   * @type {Object}\n   */\n  Utils.each(options, function(value, name) {\n    delete options[name];\n    options[Utils.toCamelCase(name)] = value;\n  });\n\n  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});\n  this.options.listenerOptions = listenerOptions;\n\n  // add some css to the element to prevent the browser from doing its native behavior\n  if (this.options.behavior) {\n    Utils.toggleBehavior(this.element, this.options.behavior, true);\n  }\n\n  /**\n   * event start handler on the element to start the detection\n   * @property eventStartHandler\n   * @type {Object}\n   */\n  this.eventStartHandler = Event.onTouch(element, EVENT_START, function(ev) {\n    if (self.enabled && ev.eventType == EVENT_START) {\n      Detection.startDetect(self, ev);\n    } else if (ev.eventType == EVENT_TOUCH) {\n      Detection.detect(ev);\n    }\n  }, listenerOptions);\n\n  /**\n   * keep a list of user event handlers which needs to be removed when calling 'dispose'\n   * @property eventHandlers\n   * @type {Array}\n   */\n  this.eventHandlers = [];\n};\n\nGestureDetector.Instance.prototype = {\n  /**\n   * @method on\n   * @signature on(gestures, handler)\n   * @description\n   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]\n   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]\n   * @param {String} gestures\n   *   [en]A space separated list of gestures.[/en]\n   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]\n   * @param {Function} handler\n   *   [en]An event handling function.[/en]\n   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]\n   */\n  on: function onEvent(gestures, handler, opt) {\n    var self = this;\n\n    Event.on(self.element, gestures, handler, util.extend({}, self.options.listenerOptions, opt), function(type) {\n      self.eventHandlers.push({ gesture: type, handler: handler });\n    });\n    return self;\n  },\n\n  /**\n   * @method off\n   * @signature off(gestures, handler)\n   * @description\n   *  [en]Remove an event listener.[/en]\n   *  [ja]イベントリスナーを削除します。[/ja]\n   * @param {String} gestures\n   *   [en]A space separated list of gestures.[/en]\n   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]\n   * @param {Function} handler\n   *   [en]An event handling function.[/en]\n   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]\n   */\n  off: function offEvent(gestures, handler, opt) {\n    var self = this;\n\n    Event.off(self.element, gestures, handler, util.extend({}, self.options.listenerOptions, opt), function(type) {\n      var index = Utils.inArray(self.eventHandlers, { gesture: type, handler: handler }, true);\n      if (index >= 0) {\n        self.eventHandlers.splice(index, 1);\n      }\n    });\n    return self;\n  },\n\n  /**\n   * trigger gesture event\n   * @method trigger\n   * @signature trigger(gesture, eventData)\n   * @param {String} gesture\n   * @param {Object} [eventData]\n   */\n  trigger: function triggerEvent(gesture, eventData) {\n    // optional\n    if (!eventData) {\n      eventData = {};\n    }\n\n    // create DOM event\n    var event = GestureDetector.DOCUMENT.createEvent('Event');\n    event.initEvent(gesture, true, true);\n    event.gesture = eventData;\n\n    // trigger on the target if it is in the instance element,\n    // this is for event delegation tricks\n    var element = this.element;\n    if (Utils.hasParent(eventData.target, element)) {\n      element = eventData.target;\n    }\n\n    element.dispatchEvent(event);\n    return this;\n  },\n\n  /**\n   * @method enable\n   * @signature enable(state)\n   * @description\n   *  [en]Enable or disable gesture detection.[/en]\n   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]\n   * @param {Boolean} state\n   *   [en]Specify if it should be enabled or not.[/en]\n   *   [ja]有効にするかどうかを指定します。[/ja]\n   */\n  enable: function enable(state) {\n    this.enabled = state;\n    return this;\n  },\n\n  /**\n   * @method dispose\n   * @signature dispose()\n   * @description\n   *  [en]Remove and destroy all event handlers for this instance.[/en]\n   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]\n   */\n  dispose: function dispose() {\n    var i, eh;\n\n    // undo all changes made by stop_browser_behavior\n    Utils.toggleBehavior(this.element, this.options.behavior, false);\n\n    // unbind all custom event handlers\n    for (i = -1; (eh = this.eventHandlers[++i]);) { // eslint-disable-line no-cond-assign\n      Utils.off(this.element, eh.gesture, eh.handler);\n    }\n\n    this.eventHandlers = [];\n\n    // unbind the start event listener\n    Event.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);\n\n    return null;\n  }\n};\n\n\n/**\n * @module gestures\n */\n/**\n * Move with x fingers (default 1) around on the page.\n * Preventing the default browser behavior is a good way to improve feel and working.\n * ````\n *  GestureDetectortime.on(\"drag\", function(ev) {\n *    console.log(ev);\n *    ev.gesture.preventDefault();\n *  });\n * ````\n *\n * @class Drag\n * @static\n */\n/**\n * @event drag\n * @param {Object} ev\n */\n/**\n * @event dragstart\n * @param {Object} ev\n */\n/**\n * @event dragend\n * @param {Object} ev\n */\n/**\n * @event drapleft\n * @param {Object} ev\n */\n/**\n * @event dragright\n * @param {Object} ev\n */\n/**\n * @event dragup\n * @param {Object} ev\n */\n/**\n * @event dragdown\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n(function(name) {\n  var triggered = false;\n\n  function dragGesture(ev, inst) {\n    var cur = Detection.current;\n\n    // max touches\n    if (inst.options.dragMaxTouches > 0 &&\n      ev.touches.length > inst.options.dragMaxTouches) {\n      return;\n    }\n\n    switch (ev.eventType) {\n    case EVENT_START:\n      triggered = false;\n      break;\n\n    case EVENT_MOVE:\n      // when the distance we moved is too small we skip this gesture\n      // or we can be already in dragging\n      if (ev.distance < inst.options.dragMinDistance &&\n        cur.name != name) {\n        return;\n      }\n\n      var startCenter = cur.startEvent.center;\n\n      // we are dragging!\n      if (cur.name != name) {\n        cur.name = name;\n        if (inst.options.dragDistanceCorrection && ev.distance > 0) {\n          // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.\n          // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.\n          // It might be useful to save the original start point somewhere\n          var factor = Math.abs(inst.options.dragMinDistance / ev.distance);\n          startCenter.pageX += ev.deltaX * factor;\n          startCenter.pageY += ev.deltaY * factor;\n          startCenter.clientX += ev.deltaX * factor;\n          startCenter.clientY += ev.deltaY * factor;\n\n          // recalculate event data using new start point\n          ev = Detection.extendEventData(ev);\n        }\n      }\n\n      // lock drag to axis?\n      if (cur.lastEvent.dragLockToAxis ||\n        ( inst.options.dragLockToAxis &&\n          inst.options.dragLockMinDistance <= ev.distance\n        )) {\n          ev.dragLockToAxis = true;\n        }\n\n        // keep direction on the axis that the drag gesture started on\n        var lastDirection = cur.lastEvent.direction;\n        if (ev.dragLockToAxis && lastDirection !== ev.direction) {\n          if (Utils.isVertical(lastDirection)) {\n            ev.direction = (ev.deltaY < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n          } else {\n            ev.direction = (ev.deltaX < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          }\n        }\n\n        // first time, trigger dragstart event\n        if (!triggered) {\n          inst.trigger(name + 'start', ev);\n          triggered = true;\n        }\n\n        // trigger events\n        inst.trigger(name, ev);\n        inst.trigger(name + ev.direction, ev);\n\n        var isVertical = Utils.isVertical(ev.direction);\n\n        // block the browser events\n        if ((inst.options.dragBlockVertical && isVertical) ||\n          (inst.options.dragBlockHorizontal && !isVertical)) {\n          ev.preventDefault();\n        }\n        break;\n\n      case EVENT_RELEASE:\n        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {\n          inst.trigger(name + 'end', ev);\n          triggered = false;\n        }\n        break;\n\n      case EVENT_END:\n        triggered = false;\n        break;\n      }\n    }\n\n    GestureDetector.gestures.Drag = {\n      name: name,\n      index: 50,\n      handler: dragGesture,\n      defaults: {\n        /**\n         * minimal movement that have to be made before the drag event gets triggered\n         * @property dragMinDistance\n         * @type {Number}\n         * @default 10\n         */\n        dragMinDistance: 10,\n\n        /**\n         * Set dragDistanceCorrection to true to make the starting point of the drag\n         * be calculated from where the drag was triggered, not from where the touch started.\n         * Useful to avoid a jerk-starting drag, which can make fine-adjustments\n         * through dragging difficult, and be visually unappealing.\n         * @property dragDistanceCorrection\n         * @type {Boolean}\n         * @default true\n         */\n        dragDistanceCorrection: true,\n\n        /**\n         * set 0 for unlimited, but this can conflict with transform\n         * @property dragMaxTouches\n         * @type {Number}\n         * @default 1\n         */\n        dragMaxTouches: 1,\n\n        /**\n         * prevent default browser behavior when dragging occurs\n         * be careful with it, it makes the element a blocking element\n         * when you are using the drag gesture, it is a good practice to set this true\n         * @property dragBlockHorizontal\n         * @type {Boolean}\n         * @default false\n         */\n        dragBlockHorizontal: false,\n\n        /**\n         * same as `dragBlockHorizontal`, but for vertical movement\n         * @property dragBlockVertical\n         * @type {Boolean}\n         * @default false\n         */\n        dragBlockVertical: false,\n\n        /**\n         * dragLockToAxis keeps the drag gesture on the axis that it started on,\n         * It disallows vertical directions if the initial direction was horizontal, and vice versa.\n         * @property dragLockToAxis\n         * @type {Boolean}\n         * @default false\n         */\n        dragLockToAxis: false,\n\n        /**\n         * drag lock only kicks in when distance > dragLockMinDistance\n         * This way, locking occurs only when the distance has become large enough to reliably determine the direction\n         * @property dragLockMinDistance\n         * @type {Number}\n         * @default 25\n         */\n        dragLockMinDistance: 25\n      }\n    };\n  })('drag');\n\n  /**\n   * @module gestures\n   */\n  /**\n   * trigger a simple gesture event, so you can do anything in your handler.\n   * only usable if you know what your doing...\n   *\n   * @class Gesture\n   * @static\n   */\n  /**\n   * @event gesture\n   * @param {Object} ev\n   */\n  GestureDetector.gestures.Gesture = {\n    name: 'gesture',\n    index: 1337,\n    handler: function releaseGesture(ev, inst) {\n      inst.trigger(this.name, ev);\n    }\n  };\n\n  /**\n   * @module gestures\n   */\n  /**\n   * Touch stays at the same place for x time\n   *\n   * @class Hold\n   * @static\n   */\n  /**\n   * @event hold\n   * @param {Object} ev\n   */\n\n  /**\n   * @param {String} name\n   */\n  (function(name) {\n    var timer;\n\n    function holdGesture(ev, inst) {\n      var options = inst.options,\n          current = Detection.current;\n\n      switch (ev.eventType) {\n      case EVENT_START:\n        clearTimeout(timer);\n\n        // set the gesture so we can check in the timeout if it still is\n        current.name = name;\n\n        // set timer and if after the timeout it still is hold,\n        // we trigger the hold event\n        timer = setTimeout(function() {\n          if (current && current.name == name) {\n            inst.trigger(name, ev);\n          }\n        }, options.holdTimeout);\n        break;\n\n      case EVENT_MOVE:\n        if (ev.distance > options.holdThreshold) {\n          clearTimeout(timer);\n        }\n        break;\n\n      case EVENT_RELEASE:\n        clearTimeout(timer);\n        break;\n      }\n    }\n\n    GestureDetector.gestures.Hold = {\n      name: name,\n      index: 10,\n      defaults: {\n        /**\n         * @property holdTimeout\n         * @type {Number}\n         * @default 500\n         */\n        holdTimeout: 500,\n\n        /**\n         * movement allowed while holding\n         * @property holdThreshold\n         * @type {Number}\n         * @default 2\n         */\n        holdThreshold: 2\n      },\n      handler: holdGesture\n    };\n  })('hold');\n\n  /**\n   * @module gestures\n   */\n  /**\n   * when a touch is being released from the page\n   *\n   * @class Release\n   * @static\n   */\n  /**\n   * @event release\n   * @param {Object} ev\n   */\n  GestureDetector.gestures.Release = {\n    name: 'release',\n    index: Infinity,\n    handler: function releaseGesture(ev, inst) {\n      if (ev.eventType == EVENT_RELEASE) {\n        inst.trigger(this.name, ev);\n      }\n    }\n  };\n\n  /**\n   * @module gestures\n   */\n  /**\n   * triggers swipe events when the end velocity is above the threshold\n   * for best usage, set `preventDefault` (on the drag gesture) to `true`\n   * ````\n   *  GestureDetectortime.on(\"dragleft swipeleft\", function(ev) {\n   *    console.log(ev);\n   *    ev.gesture.preventDefault();\n   *  });\n   * ````\n   *\n   * @class Swipe\n   * @static\n   */\n  /**\n   * @event swipe\n   * @param {Object} ev\n   */\n  /**\n   * @event swipeleft\n   * @param {Object} ev\n   */\n  /**\n   * @event swiperight\n   * @param {Object} ev\n   */\n  /**\n   * @event swipeup\n   * @param {Object} ev\n   */\n  /**\n   * @event swipedown\n   * @param {Object} ev\n   */\n  GestureDetector.gestures.Swipe = {\n    name: 'swipe',\n    index: 40,\n    defaults: {\n      /**\n       * @property swipeMinTouches\n       * @type {Number}\n       * @default 1\n       */\n      swipeMinTouches: 1,\n\n      /**\n       * @property swipeMaxTouches\n       * @type {Number}\n       * @default 1\n       */\n      swipeMaxTouches: 1,\n\n      /**\n       * horizontal swipe velocity\n       * @property swipeVelocityX\n       * @type {Number}\n       * @default 0.6\n       */\n      swipeVelocityX: 0.6,\n\n      /**\n       * vertical swipe velocity\n       * @property swipeVelocityY\n       * @type {Number}\n       * @default 0.6\n       */\n      swipeVelocityY: 0.6\n    },\n\n    handler: function swipeGesture(ev, inst) {\n      if (ev.eventType == EVENT_RELEASE) {\n        var touches = ev.touches.length,\n            options = inst.options;\n\n        // max touches\n        if (touches < options.swipeMinTouches ||\n          touches > options.swipeMaxTouches) {\n          return;\n        }\n\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if (ev.velocityX > options.swipeVelocityX ||\n          ev.velocityY > options.swipeVelocityY) {\n          // trigger swipe events\n          inst.trigger(this.name, ev);\n          inst.trigger(this.name + ev.direction, ev);\n        }\n      }\n    }\n  };\n\n  /**\n   * @module gestures\n   */\n  /**\n   * Single tap and a double tap on a place\n   *\n   * @class Tap\n   * @static\n   */\n  /**\n   * @event tap\n   * @param {Object} ev\n   */\n  /**\n   * @event doubletap\n   * @param {Object} ev\n   */\n\n  /**\n   * @param {String} name\n   */\n  (function(name) {\n    var hasMoved = false;\n\n    function tapGesture(ev, inst) {\n      var options = inst.options,\n          current = Detection.current,\n          prev = Detection.previous,\n          sincePrev,\n          didDoubleTap;\n\n      switch (ev.eventType) {\n      case EVENT_START:\n        hasMoved = false;\n        break;\n\n      case EVENT_MOVE:\n        hasMoved = hasMoved || (ev.distance > options.tapMaxDistance);\n        break;\n\n      case EVENT_END:\n        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {\n          // previous gesture, for the double tap since these are two different gesture detections\n          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;\n          didDoubleTap = false;\n\n          // check if double tap\n          if (prev && prev.name == name &&\n            (sincePrev && sincePrev < options.doubleTapInterval) &&\n            ev.distance < options.doubleTapDistance) {\n            inst.trigger('doubletap', ev);\n            didDoubleTap = true;\n          }\n\n          // do a single tap\n          if (!didDoubleTap || options.tapAlways) {\n            current.name = name;\n            inst.trigger(current.name, ev);\n          }\n        }\n        break;\n      }\n    }\n\n    GestureDetector.gestures.Tap = {\n      name: name,\n      index: 100,\n      handler: tapGesture,\n      defaults: {\n        /**\n         * max time of a tap, this is for the slow tappers\n         * @property tapMaxTime\n         * @type {Number}\n         * @default 250\n         */\n        tapMaxTime: 250,\n\n        /**\n         * max distance of movement of a tap, this is for the slow tappers\n         * @property tapMaxDistance\n         * @type {Number}\n         * @default 10\n         */\n        tapMaxDistance: 10,\n\n        /**\n         * always trigger the `tap` event, even while double-tapping\n         * @property tapAlways\n         * @type {Boolean}\n         * @default true\n         */\n        tapAlways: true,\n\n        /**\n         * max distance between two taps\n         * @property doubleTapDistance\n         * @type {Number}\n         * @default 20\n         */\n        doubleTapDistance: 20,\n\n        /**\n         * max time between two taps\n         * @property doubleTapInterval\n         * @type {Number}\n         * @default 300\n         */\n        doubleTapInterval: 300\n      }\n    };\n  })('tap');\n\n  /**\n   * @module gestures\n   */\n  /**\n   * when a touch is being touched at the page\n   *\n   * @class Touch\n   * @static\n   */\n  /**\n   * @event touch\n   * @param {Object} ev\n   */\n  GestureDetector.gestures.Touch = {\n    name: 'touch',\n    index: -Infinity,\n    defaults: {\n      /**\n       * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,\n       * but it improves gestures like transforming and dragging.\n       * be careful with using this, it can be very annoying for users to be stuck on the page\n       * @property preventDefault\n       * @type {Boolean}\n       * @default false\n       */\n      preventDefault: false,\n\n      /**\n       * disable mouse events, so only touch (or pen!) input triggers events\n       * @property preventMouse\n       * @type {Boolean}\n       * @default false\n       */\n      preventMouse: false\n    },\n    handler: function touchGesture(ev, inst) {\n      if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {\n        ev.stopDetect();\n        return;\n      }\n\n      if (inst.options.preventDefault) {\n        ev.preventDefault();\n      }\n\n      if (ev.eventType == EVENT_TOUCH) {\n        inst.trigger('touch', ev);\n      }\n    }\n  };\n\n  /**\n   * @module gestures\n   */\n  /**\n   * User want to scale or rotate with 2 fingers\n   * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the\n   * `preventDefault` option.\n   *\n   * @class Transform\n   * @static\n   */\n  /**\n   * @event transform\n   * @param {Object} ev\n   */\n  /**\n   * @event transformstart\n   * @param {Object} ev\n   */\n  /**\n   * @event transformend\n   * @param {Object} ev\n   */\n  /**\n   * @event pinchin\n   * @param {Object} ev\n   */\n  /**\n   * @event pinchout\n   * @param {Object} ev\n   */\n  /**\n   * @event rotate\n   * @param {Object} ev\n   */\n\n  /**\n   * @param {String} name\n   */\n  (function(name) {\n    var triggered = false;\n\n    function transformGesture(ev, inst) {\n      switch (ev.eventType) {\n      case EVENT_START:\n        triggered = false;\n        break;\n\n      case EVENT_MOVE:\n        // at least multitouch\n        if (ev.touches.length < 2) {\n          return;\n        }\n\n        var scaleThreshold = Math.abs(1 - ev.scale);\n        var rotationThreshold = Math.abs(ev.rotation);\n\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if (scaleThreshold < inst.options.transformMinScale &&\n          rotationThreshold < inst.options.transformMinRotation) {\n          return;\n        }\n\n        // we are transforming!\n        Detection.current.name = name;\n\n        // first time, trigger dragstart event\n        if (!triggered) {\n          inst.trigger(name + 'start', ev);\n          triggered = true;\n        }\n\n        inst.trigger(name, ev); // basic transform event\n\n        // trigger rotate event\n        if (rotationThreshold > inst.options.transformMinRotation) {\n          inst.trigger('rotate', ev);\n        }\n\n        // trigger pinch event\n        if (scaleThreshold > inst.options.transformMinScale) {\n          inst.trigger('pinch', ev);\n          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);\n        }\n        break;\n\n      case EVENT_RELEASE:\n        if (triggered && ev.changedLength < 2) {\n          inst.trigger(name + 'end', ev);\n          triggered = false;\n        }\n        break;\n      }\n    }\n\n    GestureDetector.gestures.Transform = {\n      name: name,\n      index: 45,\n      defaults: {\n        /**\n         * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n         * @property transformMinScale\n         * @type {Number}\n         * @default 0.01\n         */\n        transformMinScale: 0.01,\n\n        /**\n         * rotation in degrees\n         * @property transformMinRotation\n         * @type {Number}\n         * @default 1\n         */\n        transformMinRotation: 1\n      },\n\n      handler: transformGesture\n    };\n  })('transform');\n\nexport default GestureDetector;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}