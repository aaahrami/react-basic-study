{"ast":null,"code":"import util from '../util.js';\nimport platform from '../platform.js';\nimport animit from '../animit.js';\nimport GestureDetector from '../gesture-detector.js';\nconst directionMap = {\n  vertical: {\n    axis: 'Y',\n    size: 'Height',\n    dir: ['up', 'down'],\n    t3d: ['0px, ', 'px, 0px']\n  },\n  horizontal: {\n    axis: 'X',\n    size: 'Width',\n    dir: ['left', 'right'],\n    t3d: ['', 'px, 0px, 0px']\n  }\n};\nexport default class Swiper {\n  constructor(params) {\n    // Parameters\n    const FALSE = () => false;\n\n    `getInitialIndex getBubbleWidth isVertical isOverScrollable isCentered\n    isAutoScrollable refreshHook preChangeHook postChangeHook overScrollHook`.split(/\\s+/).forEach(key => this[key] = params[key] || FALSE);\n    this.getElement = params.getElement; // Required\n\n    this.scrollHook = params.scrollHook; // Optional\n\n    this.itemSize = params.itemSize || '100%';\n\n    this.getAutoScrollRatio = function () {\n      let ratio = params.getAutoScrollRatio && params.getAutoScrollRatio(...arguments);\n      ratio = typeof ratio === 'number' && ratio === ratio ? ratio : .5;\n\n      if (ratio < 0.0 || ratio > 1.0) {\n        util.throw('Invalid auto-scroll-ratio ' + ratio + '. Must be between 0 and 1');\n      }\n\n      return ratio;\n    }; // Prevent clicks only on desktop\n\n\n    this.shouldBlock = util.globals.actualMobileOS === 'other'; // Bind handlers\n\n    this.onDragStart = this.onDragStart.bind(this);\n    this.onDrag = this.onDrag.bind(this);\n    this.onDragEnd = this.onDragEnd.bind(this);\n    this.onResize = this.onResize.bind(this);\n    this._shouldFixScroll = util.globals.actualMobileOS === 'ios';\n  }\n\n  init() {\n    let {\n      swipeable,\n      autoRefresh\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.initialized = true;\n    this.target = this.getElement().children[0];\n    this.blocker = this.getElement().children[1];\n\n    if (!this.target || !this.blocker) {\n      util.throw('Expected \"target\" and \"blocker\" elements to exist before initializing Swiper');\n    }\n\n    if (!this.shouldBlock) {\n      this.blocker.style.display = 'none';\n    } // Add classes\n\n\n    this.getElement().classList.add('ons-swiper');\n    this.target.classList.add('ons-swiper-target');\n    this.blocker.classList.add('ons-swiper-blocker'); // Setup listeners\n\n    this._gestureDetector = new GestureDetector(this.getElement(), {\n      dragMinDistance: 1,\n      dragLockToAxis: true,\n      passive: !this._shouldFixScroll\n    });\n    this._mutationObserver = new MutationObserver(() => this.refresh());\n    this.updateSwipeable(swipeable);\n    this.updateAutoRefresh(autoRefresh); // Setup initial layout\n\n    this._scroll = this._offset = this._lastActiveIndex = 0;\n\n    this._updateLayout();\n\n    this._setupInitialIndex();\n\n    setImmediate(() => this.initialized && this._setupInitialIndex()); // Fix rendering glitch on Android 4.1\n    // Fix for iframes where the width is inconsistent at the beginning\n\n    if (window !== window.parent || this.offsetHeight === 0) {\n      window.requestAnimationFrame(() => this.initialized && this.onResize());\n    }\n  }\n\n  dispose() {\n    this.initialized = false;\n    this.updateSwipeable(false);\n    this.updateAutoRefresh(false);\n    this._gestureDetector && this._gestureDetector.dispose();\n    this.target = this.blocker = this._gestureDetector = this._mutationObserver = null;\n    this.setupResize(false);\n  }\n\n  onResize() {\n    const i = this._scroll / this.itemNumSize;\n\n    this._reset();\n\n    this.setActiveIndex(i);\n    this.refresh();\n  }\n\n  get itemCount() {\n    return this.target.children.length;\n  }\n\n  get itemNumSize() {\n    if (typeof this._itemNumSize !== 'number' || this._itemNumSize !== this._itemNumSize) {\n      this._itemNumSize = this._calculateItemSize();\n    }\n\n    return this._itemNumSize;\n  }\n\n  get maxScroll() {\n    const max = this.itemCount * this.itemNumSize - this.targetSize;\n    return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.\n  }\n\n  _calculateItemSize() {\n    const matches = this.itemSize.match(/^(\\d+)(px|%)/);\n\n    if (!matches) {\n      util.throw(`Invalid state: swiper's size unit must be '%' or 'px'`);\n    }\n\n    const value = parseInt(matches[1], 10);\n    return matches[2] === '%' ? Math.round(value / 100 * this.targetSize) : value;\n  }\n\n  _setupInitialIndex() {\n    this._reset();\n\n    this._lastActiveIndex = Math.max(Math.min(Number(this.getInitialIndex()), this.itemCount), 0);\n    this._scroll = this._offset + this.itemNumSize * this._lastActiveIndex;\n\n    this._scrollTo(this._scroll);\n  }\n\n  _setSwiping(toggle) {\n    this.target.classList.toggle('swiping', toggle); // Hides everything except shown pages\n  }\n\n  setActiveIndex(index) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    this._setSwiping(true);\n\n    index = Math.max(0, Math.min(index, this.itemCount - 1));\n    const scroll = Math.max(0, Math.min(this.maxScroll, this._offset + this.itemNumSize * index));\n    return this._changeTo(scroll, options);\n  }\n\n  getActiveIndex() {\n    let scroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._scroll;\n    scroll -= this._offset;\n    const count = this.itemCount,\n          size = this.itemNumSize;\n\n    if (this.itemNumSize === 0 || !util.isInteger(scroll)) {\n      return this._lastActiveIndex;\n    }\n\n    if (scroll <= 0) {\n      return 0;\n    }\n\n    for (let i = 0; i < count; i++) {\n      if (size * i <= scroll && size * (i + 1) > scroll) {\n        return i;\n      }\n    }\n\n    return count - 1;\n  }\n\n  setupResize(add) {\n    window[(add ? 'add' : 'remove') + 'EventListener']('resize', this.onResize, true);\n  }\n\n  show() {\n    this.setupResize(true);\n    this.onResize();\n    setTimeout(() => this.target && this.target.classList.add('active'), 1000 / 60); // Hide elements after animations\n  }\n\n  hide() {\n    this.setupResize(false);\n    this.target.classList.remove('active'); // Show elements before animations\n  }\n\n  updateSwipeable(shouldUpdate) {\n    if (this._gestureDetector) {\n      const action = shouldUpdate ? 'on' : 'off';\n\n      this._gestureDetector[action]('drag', this.onDrag);\n\n      this._gestureDetector[action]('dragstart', this.onDragStart);\n\n      this._gestureDetector[action]('dragend', this.onDragEnd);\n    }\n  }\n\n  updateAutoRefresh(shouldWatch) {\n    if (this._mutationObserver) {\n      shouldWatch ? this._mutationObserver.observe(this.target, {\n        childList: true\n      }) : this._mutationObserver.disconnect();\n    }\n  }\n\n  updateItemSize(newSize) {\n    this.itemSize = newSize || '100%';\n    this.refresh();\n  }\n\n  toggleBlocker(block) {\n    this.blocker.style.pointerEvents = block ? 'auto' : 'none';\n  }\n\n  _canConsumeGesture(gesture) {\n    const d = gesture.direction;\n    const isFirst = this._scroll === 0 && !this.isOverScrollable();\n    const isLast = this._scroll === this.maxScroll && !this.isOverScrollable();\n    return this.isVertical() ? d === 'down' && !isFirst || d === 'up' && !isLast : d === 'right' && !isFirst || d === 'left' && !isLast;\n  }\n\n  onDragStart(event) {\n    this._ignoreDrag = event.consumed || !util.isValidGesture(event);\n\n    if (!this._ignoreDrag) {\n      const consume = event.consume;\n\n      event.consume = () => {\n        consume && consume();\n        this._ignoreDrag = true;\n      };\n\n      if (this._canConsumeGesture(event.gesture)) {\n        const startX = event.gesture.center && event.gesture.center.clientX || 0,\n              distFromEdge = this.getBubbleWidth() || 0,\n              start = () => {\n          consume && consume();\n          event.consumed = true;\n          this._started = true; // Avoid starting drag from outside\n\n          this.shouldBlock && this.toggleBlocker(true);\n\n          this._setSwiping(true);\n\n          util.iosPreventScroll(this._gestureDetector);\n        }; // Let parent elements consume the gesture or consume it right away\n\n\n        startX < distFromEdge || startX > this.targetSize - distFromEdge ? setImmediate(() => !this._ignoreDrag && start()) : start();\n      }\n    }\n  }\n\n  onDrag(event) {\n    if (!event.gesture || this._ignoreDrag || !this._started) {\n      return;\n    }\n\n    this._continued = true; // Fix for random 'dragend' without 'drag'\n\n    event.stopPropagation();\n\n    this._scrollTo(this._scroll - this._getDelta(event), {\n      throttle: true\n    });\n  }\n\n  onDragEnd(event) {\n    this._started = false;\n\n    if (!event.gesture || this._ignoreDrag || !this._continued) {\n      this._ignoreDrag = true; // onDragEnd might fire before onDragStart's setImmediate\n\n      return;\n    }\n\n    this._continued = false;\n    event.stopPropagation();\n\n    const scroll = this._scroll - this._getDelta(event);\n\n    const normalizedScroll = this._normalizeScroll(scroll);\n\n    scroll === normalizedScroll ? this._startMomentumScroll(scroll, event) : this._killOverScroll(normalizedScroll);\n    this.shouldBlock && this.toggleBlocker(false);\n  }\n\n  _startMomentumScroll(scroll, event) {\n    const velocity = this._getVelocity(event),\n          matchesDirection = event.gesture.interimDirection === this.dM.dir[this._getDelta(event) < 0 ? 0 : 1];\n\n    const nextScroll = this._getAutoScroll(scroll, velocity, matchesDirection);\n\n    let duration = Math.abs(nextScroll - scroll) / (velocity + 0.01) / 1000;\n    duration = Math.min(.25, Math.max(.1, duration));\n\n    this._changeTo(nextScroll, {\n      swipe: true,\n      animationOptions: {\n        duration,\n        timing: 'cubic-bezier(.4, .7, .5, 1)'\n      }\n    });\n  }\n\n  _killOverScroll(scroll) {\n    this._scroll = scroll;\n    const direction = this.dM.dir[Number(scroll > 0)];\n\n    const killOverScroll = () => this._changeTo(scroll, {\n      animationOptions: {\n        duration: .4,\n        timing: 'cubic-bezier(.1, .4, .1, 1)'\n      }\n    });\n\n    this.overScrollHook({\n      direction,\n      killOverScroll\n    }) || killOverScroll();\n  }\n\n  _changeTo(scroll) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const e = {\n      activeIndex: this.getActiveIndex(scroll),\n      lastActiveIndex: this._lastActiveIndex,\n      swipe: options.swipe || false\n    };\n    const change = e.activeIndex !== e.lastActiveIndex;\n    const canceled = change ? this.preChangeHook(e) : false;\n    this._scroll = canceled ? this._offset + e.lastActiveIndex * this.itemNumSize : scroll;\n    this._lastActiveIndex = canceled ? e.lastActiveIndex : e.activeIndex;\n    return this._scrollTo(this._scroll, options).then(() => {\n      if (scroll === this._scroll && !canceled) {\n        this._setSwiping(false);\n\n        change && this.postChangeHook(e);\n      } else if (options.reject) {\n        this._setSwiping(false);\n\n        return Promise.reject('Canceled');\n      }\n    });\n  }\n\n  _scrollTo(scroll) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.throttle) {\n      const ratio = 0.35;\n\n      if (scroll < 0) {\n        scroll = this.isOverScrollable() ? Math.round(scroll * ratio) : 0;\n      } else {\n        const maxScroll = this.maxScroll;\n\n        if (maxScroll < scroll) {\n          scroll = this.isOverScrollable() ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;\n        }\n      }\n    }\n\n    const opt = options.animation === 'none' ? {} : options.animationOptions;\n    this.scrollHook && this.itemNumSize > 0 && this.scrollHook((scroll / this.itemNumSize).toFixed(2), options.animationOptions || {});\n    return new Promise(resolve => animit(this.target).queue({\n      transform: this._getTransform(scroll)\n    }, opt).play(resolve));\n  }\n\n  _getAutoScroll(scroll, velocity, matchesDirection) {\n    const max = this.maxScroll,\n          offset = this._offset,\n          size = this.itemNumSize;\n\n    if (!this.isAutoScrollable()) {\n      return Math.max(0, Math.min(max, scroll));\n    }\n\n    let arr = [];\n\n    for (let s = offset; s < max; s += size) {\n      arr.push(s);\n    }\n\n    arr.push(max);\n    arr = arr.sort((left, right) => Math.abs(left - scroll) - Math.abs(right - scroll)).filter((item, pos) => !pos || item !== arr[pos - 1]);\n    let result = arr[0];\n    const lastScroll = this._lastActiveIndex * size + offset;\n    const scrollRatio = Math.abs(scroll - lastScroll) / size;\n\n    if (scrollRatio <= this.getAutoScrollRatio(matchesDirection, velocity, size)) {\n      result = lastScroll;\n    } else {\n      if (scrollRatio < 1.0 && arr[0] === lastScroll && arr.length > 1) {\n        result = arr[1];\n      }\n    }\n\n    return Math.max(0, Math.min(max, result));\n  }\n\n  _reset() {\n    this._targetSize = this._itemNumSize = undefined;\n  }\n\n  _normalizeScroll(scroll) {\n    return Math.max(Math.min(scroll, this.maxScroll), 0);\n  }\n\n  refresh() {\n    this._reset();\n\n    this._updateLayout();\n\n    if (util.isInteger(this._scroll)) {\n      const scroll = this._normalizeScroll(this._scroll);\n\n      scroll !== this._scroll ? this._killOverScroll(scroll) : this._changeTo(scroll);\n    } else {\n      this._setupInitialIndex();\n    }\n\n    this.refreshHook();\n  }\n\n  get targetSize() {\n    if (!this._targetSize) {\n      this._targetSize = this.target[`offset${this.dM.size}`];\n    }\n\n    return this._targetSize;\n  }\n\n  _getDelta(event) {\n    return event.gesture[`delta${this.dM.axis}`];\n  }\n\n  _getVelocity(event) {\n    return event.gesture[`velocity${this.dM.axis}`];\n  }\n\n  _getTransform(scroll) {\n    return `translate3d(${this.dM.t3d[0]}${-scroll}${this.dM.t3d[1]})`;\n  }\n\n  _updateLayout() {\n    this.dM = directionMap[this.isVertical() ? 'vertical' : 'horizontal'];\n    this.target.classList.toggle('ons-swiper-target--vertical', this.isVertical());\n\n    for (let c = this.target.children[0]; c; c = c.nextElementSibling) {\n      c.style[this.dM.size.toLowerCase()] = this.itemSize;\n    }\n\n    if (this.isCentered()) {\n      this._offset = (this.targetSize - this.itemNumSize) / -2 || 0;\n    }\n  }\n\n}","map":{"version":3,"names":["util","platform","animit","GestureDetector","directionMap","vertical","axis","size","dir","t3d","horizontal","Swiper","constructor","params","FALSE","split","forEach","key","getElement","scrollHook","itemSize","getAutoScrollRatio","ratio","throw","shouldBlock","globals","actualMobileOS","onDragStart","bind","onDrag","onDragEnd","onResize","_shouldFixScroll","init","swipeable","autoRefresh","initialized","target","children","blocker","style","display","classList","add","_gestureDetector","dragMinDistance","dragLockToAxis","passive","_mutationObserver","MutationObserver","refresh","updateSwipeable","updateAutoRefresh","_scroll","_offset","_lastActiveIndex","_updateLayout","_setupInitialIndex","setImmediate","window","parent","offsetHeight","requestAnimationFrame","dispose","setupResize","i","itemNumSize","_reset","setActiveIndex","itemCount","length","_itemNumSize","_calculateItemSize","maxScroll","max","targetSize","Math","ceil","matches","match","value","parseInt","round","min","Number","getInitialIndex","_scrollTo","_setSwiping","toggle","index","options","scroll","_changeTo","getActiveIndex","count","isInteger","show","setTimeout","hide","remove","shouldUpdate","action","shouldWatch","observe","childList","disconnect","updateItemSize","newSize","toggleBlocker","block","pointerEvents","_canConsumeGesture","gesture","d","direction","isFirst","isOverScrollable","isLast","isVertical","event","_ignoreDrag","consumed","isValidGesture","consume","startX","center","clientX","distFromEdge","getBubbleWidth","start","_started","iosPreventScroll","_continued","stopPropagation","_getDelta","throttle","normalizedScroll","_normalizeScroll","_startMomentumScroll","_killOverScroll","velocity","_getVelocity","matchesDirection","interimDirection","dM","nextScroll","_getAutoScroll","duration","abs","swipe","animationOptions","timing","killOverScroll","overScrollHook","e","activeIndex","lastActiveIndex","change","canceled","preChangeHook","then","postChangeHook","reject","Promise","opt","animation","toFixed","resolve","queue","transform","_getTransform","play","offset","isAutoScrollable","arr","s","push","sort","left","right","filter","item","pos","result","lastScroll","scrollRatio","_targetSize","undefined","refreshHook","c","nextElementSibling","toLowerCase","isCentered"],"sources":["C:/React-app/test/ui/node_modules/onsenui/esm/ons/internal/swiper.js"],"sourcesContent":["import util from '../util.js';\nimport platform from '../platform.js';\nimport animit from '../animit.js';\nimport GestureDetector from '../gesture-detector.js';\n\nconst directionMap = {\n  vertical: {\n    axis: 'Y',\n    size: 'Height',\n    dir: ['up', 'down'],\n    t3d: ['0px, ', 'px, 0px']\n  },\n  horizontal: {\n    axis: 'X',\n    size: 'Width',\n    dir: ['left', 'right'],\n    t3d: ['', 'px, 0px, 0px']\n  }\n};\n\nexport default class Swiper {\n  constructor(params) {\n    // Parameters\n    const FALSE = (() => false);\n    `getInitialIndex getBubbleWidth isVertical isOverScrollable isCentered\n    isAutoScrollable refreshHook preChangeHook postChangeHook overScrollHook`\n      .split(/\\s+/)\n      .forEach(key => this[key] = params[key] || FALSE);\n\n    this.getElement = params.getElement; // Required\n    this.scrollHook = params.scrollHook; // Optional\n    this.itemSize = params.itemSize || '100%';\n\n    this.getAutoScrollRatio = (...args) => {\n      let ratio = params.getAutoScrollRatio && params.getAutoScrollRatio(...args);\n      ratio = typeof ratio === 'number' && ratio === ratio ? ratio : .5;\n      if (ratio < 0.0 || ratio > 1.0) {\n        util.throw('Invalid auto-scroll-ratio ' + ratio + '. Must be between 0 and 1');\n      }\n      return ratio;\n    };\n\n    // Prevent clicks only on desktop\n    this.shouldBlock = util.globals.actualMobileOS === 'other';\n\n    // Bind handlers\n    this.onDragStart = this.onDragStart.bind(this);\n    this.onDrag = this.onDrag.bind(this);\n    this.onDragEnd = this.onDragEnd.bind(this);\n    this.onResize = this.onResize.bind(this);\n\n    this._shouldFixScroll = util.globals.actualMobileOS === 'ios';\n  }\n\n  init({ swipeable, autoRefresh } = {}) {\n    this.initialized = true;\n    this.target = this.getElement().children[0];\n    this.blocker = this.getElement().children[1];\n    if (!this.target || !this.blocker) {\n      util.throw('Expected \"target\" and \"blocker\" elements to exist before initializing Swiper');\n    }\n\n    if (!this.shouldBlock) {\n      this.blocker.style.display = 'none';\n    }\n\n    // Add classes\n    this.getElement().classList.add('ons-swiper');\n    this.target.classList.add('ons-swiper-target');\n    this.blocker.classList.add('ons-swiper-blocker');\n\n    // Setup listeners\n    this._gestureDetector = new GestureDetector(this.getElement(),\n      { dragMinDistance: 1, dragLockToAxis: true, passive: !this._shouldFixScroll }\n    );\n    this._mutationObserver = new MutationObserver(() => this.refresh());\n    this.updateSwipeable(swipeable);\n    this.updateAutoRefresh(autoRefresh);\n\n    // Setup initial layout\n    this._scroll = this._offset = this._lastActiveIndex = 0;\n    this._updateLayout();\n    this._setupInitialIndex();\n    setImmediate(() => this.initialized && this._setupInitialIndex());\n\n    // Fix rendering glitch on Android 4.1\n    // Fix for iframes where the width is inconsistent at the beginning\n    if (window !== window.parent || this.offsetHeight === 0) {\n      window.requestAnimationFrame(() => this.initialized && this.onResize());\n    }\n  }\n\n  dispose() {\n    this.initialized = false;\n    this.updateSwipeable(false);\n    this.updateAutoRefresh(false);\n\n    this._gestureDetector && this._gestureDetector.dispose();\n    this.target = this.blocker = this._gestureDetector = this._mutationObserver = null;\n\n    this.setupResize(false);\n  }\n\n  onResize() {\n    const i = this._scroll / this.itemNumSize;\n    this._reset();\n    this.setActiveIndex(i);\n    this.refresh();\n  }\n\n  get itemCount() {\n    return this.target.children.length;\n  }\n\n  get itemNumSize() {\n    if (typeof this._itemNumSize !== 'number' || this._itemNumSize !== this._itemNumSize) {\n      this._itemNumSize = this._calculateItemSize();\n    }\n    return this._itemNumSize;\n  }\n\n  get maxScroll() {\n    const max = this.itemCount * this.itemNumSize - this.targetSize;\n    return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.\n  }\n\n  _calculateItemSize() {\n    const matches = this.itemSize.match(/^(\\d+)(px|%)/);\n\n    if (!matches) {\n      util.throw(`Invalid state: swiper's size unit must be '%' or 'px'`);\n    }\n\n    const value = parseInt(matches[1], 10);\n    return matches[2] === '%' ? Math.round(value / 100 * this.targetSize) : value;\n  }\n\n  _setupInitialIndex() {\n    this._reset();\n    this._lastActiveIndex = Math.max(Math.min(Number(this.getInitialIndex()), this.itemCount), 0);\n    this._scroll = this._offset + this.itemNumSize * this._lastActiveIndex;\n    this._scrollTo(this._scroll);\n  }\n\n  _setSwiping(toggle) {\n    this.target.classList.toggle('swiping', toggle); // Hides everything except shown pages\n  }\n\n  setActiveIndex(index, options = {}) {\n    this._setSwiping(true);\n    index = Math.max(0, Math.min(index, this.itemCount - 1));\n    const scroll = Math.max(0, Math.min(this.maxScroll, this._offset + this.itemNumSize * index));\n\n    return this._changeTo(scroll, options);\n  }\n\n  getActiveIndex(scroll = this._scroll) {\n    scroll -= this._offset;\n    const count = this.itemCount,\n      size = this.itemNumSize;\n\n    if (this.itemNumSize === 0 || !util.isInteger(scroll)) {\n      return this._lastActiveIndex;\n    }\n\n    if (scroll <= 0) {\n      return 0;\n    }\n\n    for (let i = 0; i < count; i++) {\n      if (size * i <= scroll && size * (i + 1) > scroll) {\n        return i;\n      }\n    }\n\n    return count - 1;\n  }\n\n  setupResize(add) {\n    window[(add ? 'add' : 'remove') + 'EventListener']('resize', this.onResize, true);\n  }\n\n  show() {\n    this.setupResize(true);\n    this.onResize();\n    setTimeout(() => this.target && this.target.classList.add('active'), 1000/60); // Hide elements after animations\n  }\n\n  hide() {\n    this.setupResize(false);\n    this.target.classList.remove('active'); // Show elements before animations\n  }\n\n  updateSwipeable(shouldUpdate) {\n    if (this._gestureDetector) {\n      const action = shouldUpdate ? 'on' : 'off';\n      this._gestureDetector[action]('drag', this.onDrag);\n      this._gestureDetector[action]('dragstart', this.onDragStart);\n      this._gestureDetector[action]('dragend', this.onDragEnd);\n    }\n  }\n\n  updateAutoRefresh(shouldWatch) {\n    if (this._mutationObserver) {\n      shouldWatch\n        ? this._mutationObserver.observe(this.target, { childList: true })\n        : this._mutationObserver.disconnect();\n    }\n  }\n\n  updateItemSize(newSize) {\n    this.itemSize = newSize || '100%';\n    this.refresh();\n  }\n\n  toggleBlocker(block) {\n    this.blocker.style.pointerEvents = block ? 'auto' : 'none';\n  }\n\n  _canConsumeGesture(gesture) {\n    const d = gesture.direction;\n    const isFirst = this._scroll === 0 && !this.isOverScrollable();\n    const isLast = this._scroll === this.maxScroll && !this.isOverScrollable();\n\n    return this.isVertical()\n      ? ((d === 'down' && !isFirst) || (d === 'up' && !isLast))\n      : ((d === 'right' && !isFirst) || (d === 'left' && !isLast));\n  }\n\n  onDragStart(event) {\n    this._ignoreDrag = event.consumed || !util.isValidGesture(event);\n\n    if (!this._ignoreDrag) {\n      const consume = event.consume;\n      event.consume = () => { consume && consume(); this._ignoreDrag = true; };\n\n      if (this._canConsumeGesture(event.gesture)) {\n        const startX = event.gesture.center && event.gesture.center.clientX || 0,\n          distFromEdge = this.getBubbleWidth() || 0,\n          start = () => {\n            consume && consume();\n            event.consumed = true;\n            this._started = true; // Avoid starting drag from outside\n            this.shouldBlock && this.toggleBlocker(true);\n            this._setSwiping(true);\n            util.iosPreventScroll(this._gestureDetector);\n          };\n\n        // Let parent elements consume the gesture or consume it right away\n        startX < distFromEdge || startX > (this.targetSize - distFromEdge)\n          ? setImmediate(() => !this._ignoreDrag && start())\n          : start();\n      }\n    }\n  }\n\n  onDrag(event) {\n    if (!event.gesture || this._ignoreDrag || !this._started) {\n      return;\n    }\n\n    this._continued = true; // Fix for random 'dragend' without 'drag'\n    event.stopPropagation();\n\n    this._scrollTo(this._scroll - this._getDelta(event), { throttle: true });\n  }\n\n  onDragEnd(event) {\n    this._started = false;\n    if (!event.gesture || this._ignoreDrag || !this._continued) {\n      this._ignoreDrag = true; // onDragEnd might fire before onDragStart's setImmediate\n      return;\n    }\n\n    this._continued = false;\n    event.stopPropagation();\n\n    const scroll = this._scroll - this._getDelta(event);\n    const normalizedScroll = this._normalizeScroll(scroll);\n    scroll === normalizedScroll ? this._startMomentumScroll(scroll, event) : this._killOverScroll(normalizedScroll);\n    this.shouldBlock && this.toggleBlocker(false);\n  }\n\n  _startMomentumScroll(scroll, event) {\n    const velocity = this._getVelocity(event),\n      matchesDirection = event.gesture.interimDirection === this.dM.dir[this._getDelta(event) < 0 ? 0 : 1];\n\n    const nextScroll = this._getAutoScroll(scroll, velocity, matchesDirection);\n    let duration = Math.abs(nextScroll - scroll) / (velocity + 0.01) / 1000;\n    duration = Math.min(.25, Math.max(.1, duration));\n\n    this._changeTo(nextScroll, { swipe: true, animationOptions: { duration, timing: 'cubic-bezier(.4, .7, .5, 1)' } });\n  }\n\n  _killOverScroll(scroll) {\n    this._scroll = scroll;\n    const direction = this.dM.dir[Number(scroll > 0)];\n    const killOverScroll = () => this._changeTo(scroll, { animationOptions: { duration: .4, timing: 'cubic-bezier(.1, .4, .1, 1)' } });\n    this.overScrollHook({ direction, killOverScroll }) || killOverScroll();\n  }\n\n  _changeTo(scroll, options = {}) {\n    const e = { activeIndex: this.getActiveIndex(scroll), lastActiveIndex: this._lastActiveIndex, swipe: options.swipe || false };\n    const change = e.activeIndex !== e.lastActiveIndex;\n    const canceled = change ? this.preChangeHook(e) : false;\n\n    this._scroll = canceled ? this._offset + e.lastActiveIndex * this.itemNumSize : scroll;\n    this._lastActiveIndex = canceled ? e.lastActiveIndex : e.activeIndex;\n\n    return this._scrollTo(this._scroll, options).then(() => {\n      if (scroll === this._scroll && !canceled) {\n        this._setSwiping(false);\n        change && this.postChangeHook(e);\n      } else if (options.reject) {\n        this._setSwiping(false);\n        return Promise.reject('Canceled');\n      }\n    });\n  }\n\n  _scrollTo(scroll, options = {}) {\n    if (options.throttle) {\n      const ratio = 0.35;\n      if (scroll < 0) {\n        scroll = this.isOverScrollable() ? Math.round(scroll * ratio) : 0;\n      } else {\n        const maxScroll = this.maxScroll;\n        if (maxScroll < scroll) {\n          scroll = this.isOverScrollable() ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;\n        }\n      }\n    }\n\n    const opt = options.animation  === 'none' ? {} : options.animationOptions;\n    this.scrollHook && this.itemNumSize > 0 && this.scrollHook((scroll / this.itemNumSize).toFixed(2), options.animationOptions || {});\n\n    return new Promise(resolve =>\n      animit(this.target)\n        .queue({ transform: this._getTransform(scroll) }, opt)\n        .play(resolve)\n    );\n  }\n\n  _getAutoScroll(scroll, velocity, matchesDirection) {\n    const max = this.maxScroll,\n      offset = this._offset,\n      size = this.itemNumSize;\n\n    if (!this.isAutoScrollable()) {\n      return Math.max(0, Math.min(max, scroll));\n    }\n\n    let arr = [];\n    for (let s = offset; s < max; s += size) {\n      arr.push(s);\n    }\n    arr.push(max);\n\n    arr = arr\n      .sort((left, right) => Math.abs(left - scroll) - Math.abs(right - scroll))\n      .filter((item, pos) => !pos || item !== arr[pos - 1]);\n\n    let result = arr[0];\n    const lastScroll = this._lastActiveIndex * size + offset;\n    const scrollRatio = Math.abs(scroll - lastScroll) / size;\n\n    if (scrollRatio <= this.getAutoScrollRatio(matchesDirection, velocity, size)) {\n      result = lastScroll;\n    } else {\n      if (scrollRatio < 1.0 && arr[0] === lastScroll && arr.length > 1) {\n        result = arr[1];\n      }\n    }\n    return Math.max(0, Math.min(max, result));\n  }\n\n  _reset() {\n    this._targetSize = this._itemNumSize = undefined;\n  }\n\n  _normalizeScroll(scroll) {\n    return Math.max( Math.min(scroll, this.maxScroll), 0);\n  }\n\n  refresh() {\n    this._reset();\n    this._updateLayout();\n\n    if (util.isInteger(this._scroll)) {\n      const scroll = this._normalizeScroll(this._scroll);\n      scroll !== this._scroll ? this._killOverScroll(scroll) : this._changeTo(scroll);\n    } else {\n      this._setupInitialIndex();\n    }\n\n    this.refreshHook();\n  }\n\n  get targetSize() {\n    if (!this._targetSize) {\n      this._targetSize = this.target[`offset${this.dM.size}`];\n    }\n    return this._targetSize;\n  }\n\n  _getDelta(event) {\n    return event.gesture[`delta${this.dM.axis}`];\n  }\n\n  _getVelocity(event) {\n    return event.gesture[`velocity${this.dM.axis}`];\n  }\n\n  _getTransform(scroll) {\n    return `translate3d(${this.dM.t3d[0]}${-scroll}${this.dM.t3d[1]})`;\n  }\n\n  _updateLayout() {\n    this.dM = directionMap[this.isVertical() ? 'vertical' : 'horizontal'];\n    this.target.classList.toggle('ons-swiper-target--vertical', this.isVertical());\n\n    for (let c = this.target.children[0]; c; c = c.nextElementSibling) {\n      c.style[this.dM.size.toLowerCase()] = this.itemSize;\n    }\n\n    if (this.isCentered()) {\n      this._offset = (this.targetSize - this.itemNumSize) / -2 || 0;\n    }\n  }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}